// ////////////////////////////////////////////////////////////////////////////
// ////////////////////////////////////////////////////////////////////////////
//	TibCo/Rendezvous Support Library Module
// ////////////////////////////////////////////////////////////////////////////
/*
	File Name			:	%M%

	File Version		:	%I%

	Last Extracted		:	%D%	%T%

	Last Updated		:	%E%	%U%

	File Description	:	Implementation of the SNDSpec class.

	Revision History	:	2001-10-01 --- Creation.
									Michael L. Brock

		Copyright Michael L. Brock 2001 - 2015.
		Distributed under the Boost Software License, Version 1.0.
		(See accompanying file LICENSE_1_0.txt or copy at
		http://www.boost.org/LICENSE_1_0.txt)

*/
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
// ////////////////////////////////////////////////////////////////////////////
//	Required include files...
// ////////////////////////////////////////////////////////////////////////////

#include <RvUtilX/RvParseCmdLineArg.hpp>

#include <Utility/StringSupport.hpp>

// ////////////////////////////////////////////////////////////////////////////

namespace MLB {

namespace RvUtilX {

// ////////////////////////////////////////////////////////////////////////////
SNDSpec::SNDSpec(const char *service, const char *network,
	const char *daemon) :
	 service_((service == NULL) ? "" : service)
	,network_((network == NULL) ? "" : network)
	,daemon_((daemon == NULL) ? "" : daemon)
{
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
SNDSpec::SNDSpec(const std::string &service, const std::string &network,
	const std::string &daemon) :
	 service_(service)
	,network_(network)
	,daemon_(daemon)
{
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
SNDSpec::SNDSpec(tibrvTransport &source_transport) :
	 service_()
	,network_()
	,daemon_()
{
	*this = FromTransport(source_transport);
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
SNDSpec::SNDSpec(TibrvTransport &source_transport) :
	 service_()
	,network_()
	,daemon_()
{
	*this = FromTransport(source_transport);
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
SNDSpec::SNDSpec(const MLB::Utility::StringVector &string_list) :
	 service_()
	,network_()
	,daemon_()
{
	if (string_list.size() > 3)
		MLB::Utility::ThrowInvalidArgument("The vector of strings passed to the "
			"'SNDSpec' constructor exceeds the maximum length (3).");

	if (!string_list.empty()) {
		SetService(string_list[0]);
		if (string_list.size() > 1) {
			SetNetwork(string_list[1]);
			if (string_list.size() > 2)
				SetDaemon(string_list[2]);
		}
	}
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
void SNDSpec::SetService(const std::string &datum)
{
	service_ = datum;
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
void SNDSpec::SetNetwork(const std::string &datum)
{
	network_ = datum;
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
void SNDSpec::SetDaemon(const std::string &datum)
{
	daemon_ = datum;
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
void SNDSpec::SetService(const char *datum)
{
	service_ = (datum != NULL) ? datum : "";
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
void SNDSpec::SetNetwork(const char *datum)
{
	network_ = (datum != NULL) ? datum : "";
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
void SNDSpec::SetDaemon(const char *datum)
{
	daemon_ = (datum != NULL) ? datum : "";
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
void SNDSpec::SetServiceNetworkDaemon(const std::string &service,
	const std::string &network, const std::string &daemon)
{
	SetService(service);
	SetNetwork(network);
	SetDaemon(daemon);
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
void SNDSpec::SetServiceNetworkDaemon(const char *service, const char *network,
	const char *daemon)
{
	SetService(service);
	SetNetwork(network);
	SetDaemon(daemon);
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
bool SNDSpec::ParseCmdLineServiceNetworkDaemon(unsigned int &current_index,
	int argc, char **argv)
{
	return(RvParseCmdLineArg::ParseCmdLineServiceNetworkDaemon(current_index,
		argc, argv, service_, network_, daemon_));
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
bool SNDSpec::ParseCmdLineServiceNetworkDaemonFT(unsigned int &current_index,
	int argc, char **argv)
{
	return(RvParseCmdLineArg::ParseCmdLineServiceNetworkDaemonFT(current_index,
		argc, argv, service_, network_, daemon_));
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
std::string SNDSpec::GetService() const
{
	return(service_);
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
std::string SNDSpec::GetNetwork() const
{
	return(network_);
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
std::string SNDSpec::GetDaemon() const
{
	return(daemon_);
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
std::string SNDSpec::GetServiceDescription() const
{
	return(ToStringItem(service_));
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
std::string SNDSpec::GetNetworkDescription() const
{
	return(ToStringItem(network_));
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
std::string SNDSpec::GetDaemonDescription() const
{
	return(ToStringItem(daemon_));
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
void SNDSpec::CreateTransport(TibrvNetTransport &transport) const
{
	if (transport.isValid())
		throw RvException("The specified Tib/Rendezvous transport already "
			"exists.");

	TibrvStatus rv_status = transport.create(GetService().c_str(),
		GetNetwork().c_str(), GetDaemon().c_str());

	if (rv_status != TIBRV_OK) {
		std::ostringstream error_text;
		error_text << "Unable to create a transport using " <<
			ToString() << ".";
		throw RvExceptionStatus(rv_status, error_text);
	}
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
std::string SNDSpec::ToString() const
{
	std::string out_string;

	return(ToString(out_string));
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
std::string &SNDSpec::ToString(std::string &out_string) const
{
	std::ostringstream snd_text;

	snd_text << "Service=" << ToStringItem(service_) << ", Network=" <<
		ToStringItem(network_) << ", Daemon=" << ToStringItem(daemon_);

	return(out_string.assign(snd_text.str()));
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
std::string SNDSpec::ToStringSimple() const
{
	std::string out_string;

	return(ToStringSimple(out_string));
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
std::string &SNDSpec::ToStringSimple(std::string &out_string,
	const std::string &delimiter) const
{
	std::ostringstream snd_text;

	snd_text << service_ << delimiter << network_ << delimiter << daemon_;

	return(out_string.assign(snd_text.str()));
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
std::string SNDSpec::ToStringLines(unsigned int padding,
	const std::string &separator, const std::string &preface) const
{
	std::string out_string;

	return(ToStringLines(out_string, padding, separator, preface));
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
std::string &SNDSpec::ToStringLines(std::string &out_string,
  	unsigned int padding, const std::string &separator,
	const std::string &preface) const
{
	std::ostringstream o_str;

	o_str <<
		std::left << std::setw(static_cast<std::streamsize>(padding)) <<
			(preface + "Service") <<
			std::right << separator << service_ << std::endl <<
		std::left << std::setw(static_cast<std::streamsize>(padding)) <<
			(preface + "Network") <<
			std::right << separator << network_ << std::endl <<
		std::left << std::setw(static_cast<std::streamsize>(padding)) <<
			(preface + "Daemon")  <<
			std::right << separator << daemon_;

	return(out_string.assign(o_str.str()));
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
MLB::Utility::StringVector SNDSpec::ToArgvList(const std::string &quote_char,
	const std::string &prefix) const
{
	return(ToArgvList(*this, quote_char, prefix));
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
void SNDSpec::swap(SNDSpec &other)
{
	service_.swap(other.service_);
	network_.swap(other.network_);
	daemon_.swap(other.daemon_);
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
bool SNDSpec::operator < (const SNDSpec &other) const
{
	if (service_ < other.service_)
		return(true);
	else if (service_ == other.service_) {
		if (network_ < other.network_)
			return(true);
		else if ((network_ == other.network_) && (daemon_ < other.daemon_))
			return(true);
	}

	return(false);
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
bool SNDSpec::operator == (const SNDSpec &other) const
{
	return((service_ == other.service_) && (network_ == other.network_) &&
		(daemon_ == other.daemon_));
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
bool SNDSpec::operator != (const SNDSpec &other) const
{
	return(!(*this == other));
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
int SNDSpec::CompareServiceAndNetwork(const std::string &service,
	const std::string &network) const
{
	int cmp;

	if ((cmp = stricmp(service_.c_str(), service.c_str())) == 0)
		cmp = stricmp(network_.c_str(), network.c_str());

	return(cmp);
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
int SNDSpec::CompareServiceAndNetwork(const SNDSpec &other) const
{
	return(CompareServiceAndNetwork(other.service_, other.network_));
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
MLB::Utility::StringVector SNDSpec::ToArgvList(const SNDSpec &snd_spec,
	const std::string &quote_char, const std::string &prefix)
{
	MLB::Utility::StringVector argv_list;

	if (!snd_spec.service_.empty()) {
		argv_list.push_back(prefix + "service");
		argv_list.push_back((snd_spec.service_.empty()) ?
			(quote_char + quote_char)  :
			(quote_char + snd_spec.service_ + quote_char));
	}

	if (!snd_spec.network_.empty()) {
		argv_list.push_back(prefix + "network");
		argv_list.push_back((snd_spec.network_.empty()) ?
			(quote_char + quote_char) :
			(quote_char + snd_spec.network_ + quote_char));
	}

	if (!snd_spec.daemon_.empty()) {
		argv_list.push_back(prefix + "daemon");
		argv_list.push_back((snd_spec.daemon_.empty()) ?
			(quote_char + quote_char) :
			(quote_char + snd_spec.daemon_ + quote_char));
	}

	return(argv_list);
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
SNDSpec SNDSpec::FromDelimitedString(const std::string &in_string,
	const std::string &delimiter)
{
	MLB::Utility::StringVector element_list;

	MLB::Utility::SplitString(in_string, delimiter, element_list, 0, false);

	return(SNDSpec(element_list));
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
SNDSpec SNDSpec::FromTransport(TibrvTransport &source_transport)
{
	return(FromTransport(source_transport.getHandle()));
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
SNDSpec SNDSpec::FromTransport(tibrvTransport source_transport)
{
	SNDSpec datum;

	try {
		const char *tmp_ptr;
		RvUtilX_THROW_TIBRV_STATUS_IF(tibrvTransport_GetService,
			(source_transport, &tmp_ptr));
		datum.SetService(tmp_ptr);
		RvUtilX_THROW_TIBRV_STATUS_IF(tibrvTransport_GetNetwork,
			(source_transport, &tmp_ptr));
		datum.SetNetwork(tmp_ptr);
		RvUtilX_THROW_TIBRV_STATUS_IF(tibrvTransport_GetDaemon,
			(source_transport, &tmp_ptr));
		datum.SetDaemon(tmp_ptr);
	}
	catch (const std::exception &except) {
		std::ostringstream error_text;
		error_text << "The attempt to retrieve the service, network and "
			"daemon information from the specified transport could not be "
			"completed --- the transport in question may not be a network "
			"transport: " << except.what();
		MLB::Utility::Rethrow(except, error_text);
	}

	return(datum);
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
std::string SNDSpec::ToStringItem(const std::string &item_ref) const
{
	if (item_ref.empty())
		return("*DEFAULT*");

	return("'" + item_ref + "'");
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
std::ostream & operator << (std::ostream &o_str, const SNDSpec &datum)
{
	o_str << datum.ToString();

	return(o_str);
}
// ////////////////////////////////////////////////////////////////////////////

} // namespace RvUtilX

} // namespace MLB

