// ////////////////////////////////////////////////////////////////////////////
// ////////////////////////////////////////////////////////////////////////////
//	MLB Utility Library Module File
// ////////////////////////////////////////////////////////////////////////////
/*
	File Name			:	%M%

	File Version		:	%I%

	Last Extracted		:	%D%	%T%

	Last Updated		:	%E%	%U%

	File Description	:	Implementation of the TimeSpec class.

	Revision History	:	1998-04-08 --- Creation.
									Michael L. Brock

		Copyright Michael L. Brock 1998 - 2017.
		Distributed under the Boost Software License, Version 1.0.
		(See accompanying file LICENSE_1_0.txt or copy at
		http://www.boost.org/LICENSE_1_0.txt)

*/
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
// ////////////////////////////////////////////////////////////////////////////
//	Required include files...
// ////////////////////////////////////////////////////////////////////////////

#include <Utility/TimeSupport.hpp>
#include <Utility/Utility_Exception.hpp>

// ////////////////////////////////////////////////////////////////////////////

//	Note: TimeSpec::AddSecondsInternal() is implemented in Time.cpp.

namespace MLB {

namespace Utility {

namespace {
//	////////////////////////////////////////////////////////////////////////////
//	////////////////////////////////////////////////////////////////////////////
//	Used to get high-granularity times under Windows...
//	////////////////////////////////////////////////////////////////////////////
#ifdef _Windows
typedef union {
	FILETIME         struct_data;
	unsigned __int64 scalar_data;
} WIN32_FILETIME_64;
# ifdef __MINGW32__
#  define WIN32_FILETIME_EPOCH_BIAS	116444736000000000LL
# else
#  define WIN32_FILETIME_EPOCH_BIAS	116444736000000000i64
# endif // # ifdef __MINGW32__
#endif // #ifdef _Windows
//	////////////////////////////////////////////////////////////////////////////
} // Anonymous namespace

//	////////////////////////////////////////////////////////////////////////////
TimeSpec::TimeSpec()
{
	*this = TimeSpec::Now();
}
//	////////////////////////////////////////////////////////////////////////////

//	////////////////////////////////////////////////////////////////////////////
TimeSpec::TimeSpec(time_t in_secs, long in_nsecs)
{
	tv_sec  = static_cast<long>(in_secs);
	tv_nsec = in_nsecs;
}
//	////////////////////////////////////////////////////////////////////////////

//	////////////////////////////////////////////////////////////////////////////
TimeSpec::TimeSpec(const timespec &in_time)
	:timespec(in_time)
{
}
//	////////////////////////////////////////////////////////////////////////////

//	////////////////////////////////////////////////////////////////////////////
TimeSpec::TimeSpec(const timeval &in_time)
{
	tv_sec  = in_time.tv_sec;
	tv_nsec = in_time.tv_usec * 1000;
}
//	////////////////////////////////////////////////////////////////////////////

//	////////////////////////////////////////////////////////////////////////////
TimeSpec::TimeSpec(const std::string &in_date)
	:timespec(FromString(in_date))
{
}
//	////////////////////////////////////////////////////////////////////////////

//	////////////////////////////////////////////////////////////////////////////
TimeSpec::~TimeSpec()
{
}
//	////////////////////////////////////////////////////////////////////////////

//	////////////////////////////////////////////////////////////////////////////
bool TimeSpec::operator <  (const TimeSpec &other) const
{
	return(Compare(this, &other) <  0);
}
//	////////////////////////////////////////////////////////////////////////////

//	////////////////////////////////////////////////////////////////////////////
bool TimeSpec::operator >  (const TimeSpec &other) const
{
	return(Compare(this, &other) >  0);
}
//	////////////////////////////////////////////////////////////////////////////

//	////////////////////////////////////////////////////////////////////////////
bool TimeSpec::operator <= (const TimeSpec &other) const
{
	return(Compare(this, &other) <= 0);
}
//	////////////////////////////////////////////////////////////////////////////

//	////////////////////////////////////////////////////////////////////////////
bool TimeSpec::operator >= (const TimeSpec &other) const
{
	return(Compare(this, &other) >= 0);
}
//	////////////////////////////////////////////////////////////////////////////

//	////////////////////////////////////////////////////////////////////////////
bool TimeSpec::operator == (const TimeSpec &other) const
{
	return(Compare(this, &other) == 0);
}
//	////////////////////////////////////////////////////////////////////////////

//	////////////////////////////////////////////////////////////////////////////
bool TimeSpec::operator != (const TimeSpec &other) const
{
	return(Compare(this, &other) != 0);
}
//	////////////////////////////////////////////////////////////////////////////

//	////////////////////////////////////////////////////////////////////////////
int TimeSpec::Compare(const TimeSpec &other) const
{
	return(Compare(this, &other));
}
//	////////////////////////////////////////////////////////////////////////////

//	////////////////////////////////////////////////////////////////////////////
TimeSpec &TimeSpec::SetToNow()
{
	Now().swap(*this);

	return(*this);
}
//	////////////////////////////////////////////////////////////////////////////

//	////////////////////////////////////////////////////////////////////////////
TimeSpec &TimeSpec::SetToMinimumValue()
{
	tv_sec  = 0;
	tv_nsec = 0;

	return(*this);
}
//	////////////////////////////////////////////////////////////////////////////

//	////////////////////////////////////////////////////////////////////////////
TimeSpec &TimeSpec::SetToMaximumValue()
{
	tv_sec  = std::numeric_limits<long>::max();
	tv_nsec = 999999999;

	return(*this);
}
//	////////////////////////////////////////////////////////////////////////////

//	////////////////////////////////////////////////////////////////////////////
bool TimeSpec::IsZero() const
{
	return((tv_sec == 0) && (tv_nsec == 0));
}
//	////////////////////////////////////////////////////////////////////////////

//	////////////////////////////////////////////////////////////////////////////
TimeSpec &TimeSpec::AddMilliseconds(int msecs_to_add)
{
	int secs_to_add = msecs_to_add / 1000;
	int new_nsec    = tv_nsec + ((msecs_to_add % 1000) * 1000000);

	if (new_nsec >= 1000000000) {
		secs_to_add += new_nsec / 1000000000;
		new_nsec    %= 1000000000;
	}
	else if (new_nsec < 0) {
		secs_to_add += -1 + (new_nsec / 1000000000);
		new_nsec     = 1000000000 + (new_nsec % 1000000000);
	}

	if (secs_to_add) {
		try {
			AddSeconds(secs_to_add);
		}
		catch (const std::exception &except) {
			Rethrow(except, "Unable to add the requested number of milliseconds "
				"(" + AnyToString(msecs_to_add) + "): " +
				std::string(except.what()));
		}
	}

	tv_nsec = new_nsec;

	return(*this);
}
//	////////////////////////////////////////////////////////////////////////////

//	////////////////////////////////////////////////////////////////////////////
TimeSpec &TimeSpec::AddMicroseconds(int usecs_to_add)
{
	int secs_to_add = usecs_to_add / 1000000;
	int new_nsec    = tv_nsec + ((usecs_to_add % 1000000) * 1000);

	if (new_nsec >= 1000000000) {
		secs_to_add += new_nsec / 1000000000;
		new_nsec    %= 1000000000;
	}
	else if (new_nsec < 0) {
		secs_to_add += -1 + (new_nsec / 1000000000);
		new_nsec     = 1000000000 + (new_nsec % 1000000000);
	}

	if (secs_to_add) {
		try {
			AddSeconds(secs_to_add);
		}
		catch (const std::exception &except) {
			Rethrow(except, "Unable to add the requested number of microseconds "
				"(" + AnyToString(usecs_to_add) + "): " +
				std::string(except.what()));
		}
	}

	tv_nsec = new_nsec;

	return(*this);
}
//	////////////////////////////////////////////////////////////////////////////

//	////////////////////////////////////////////////////////////////////////////
TimeSpec &TimeSpec::AddNanoseconds(int nsecs_to_add)
{
	int secs_to_add = nsecs_to_add / 1000000000;
	int new_nsec    = tv_nsec + (nsecs_to_add % 1000000000);

	if (new_nsec >= 1000000000) {
		secs_to_add += new_nsec / 1000000000;
		new_nsec    %= 1000000000;
	}
	else if (new_nsec < 0) {
		secs_to_add += -1 + (new_nsec / 1000000000);
		new_nsec     = 1000000000 + (new_nsec % 1000000000);
	}

	if (secs_to_add) {
		try {
			AddSeconds(secs_to_add);
		}
		catch (const std::exception &except) {
			Rethrow(except, "Unable to add the requested number of nanoseconds "
				"(" + AnyToString(nsecs_to_add) + "): " +
				std::string(except.what()));
		}
	}

	tv_nsec = new_nsec;

	return(*this);
}
//	////////////////////////////////////////////////////////////////////////////

//	////////////////////////////////////////////////////////////////////////////
void TimeSpec::swap(TimeSpec &other)
{
	std::swap(tv_sec, other.tv_sec);
	std::swap(tv_nsec, other.tv_nsec);
}
//	////////////////////////////////////////////////////////////////////////////

//	////////////////////////////////////////////////////////////////////////////
char *TimeSpec::ToString(char *buffer, unsigned int max_length) const
{
	return(FormatString(TimeTM::TimeUTC(tv_sec), buffer, max_length));
}
//	////////////////////////////////////////////////////////////////////////////

//	////////////////////////////////////////////////////////////////////////////
std::string TimeSpec::ToString(unsigned int max_length) const
{
	char buffer[Length_TimeSpec + 1];

	return(ToString(buffer, max_length));
}
//	////////////////////////////////////////////////////////////////////////////

//	////////////////////////////////////////////////////////////////////////////
std::string &TimeSpec::ToString(std::string &out_string,
	unsigned int max_length) const
{
	char buffer[Length_TimeSpec + 1];

	return(out_string.assign(ToString(buffer, max_length)));
}
//	////////////////////////////////////////////////////////////////////////////

//	////////////////////////////////////////////////////////////////////////////
char *TimeSpec::ToStringLocal(char *buffer, unsigned int max_length) const
{
	return(FormatString(TimeTM::TimeLocal(tv_sec), buffer, max_length));
}
//	////////////////////////////////////////////////////////////////////////////

//	////////////////////////////////////////////////////////////////////////////
std::string TimeSpec::ToStringLocal(unsigned int max_length) const
{
	char buffer[Length_TimeSpec + 1];

	return(ToStringLocal(buffer, max_length));
}
//	////////////////////////////////////////////////////////////////////////////

//	////////////////////////////////////////////////////////////////////////////
std::string &TimeSpec::ToStringLocal(std::string &out_string,
	unsigned int max_length) const
{
	char buffer[Length_TimeSpec + 1];

	return(out_string.assign(ToStringLocal(buffer, max_length)));
}
//	////////////////////////////////////////////////////////////////////////////

//	////////////////////////////////////////////////////////////////////////////
char *TimeSpec::ToStringInterval(char *buffer, unsigned int max_length) const
{
	return(FormatStringInterval(buffer, max_length));
}
//	////////////////////////////////////////////////////////////////////////////

//	////////////////////////////////////////////////////////////////////////////
std::string TimeSpec::ToStringInterval(unsigned int max_length) const
{
	char buffer[LengthInterval_TimeSpec + 1];

	return(ToStringInterval(buffer, max_length));
}
//	////////////////////////////////////////////////////////////////////////////

//	////////////////////////////////////////////////////////////////////////////
std::string &TimeSpec::ToStringInterval(std::string &out_string,
	unsigned int max_length) const
{
	char buffer[LengthInterval_TimeSpec + 1];

	return(out_string.assign(ToStringInterval(buffer, max_length)));
}
//	////////////////////////////////////////////////////////////////////////////

//	////////////////////////////////////////////////////////////////////////////
TimeT TimeSpec::ToTimeT() const
{
	return(TimeT(tv_sec));
}
//	////////////////////////////////////////////////////////////////////////////

//	////////////////////////////////////////////////////////////////////////////
TimeVal TimeSpec::ToTimeVal() const
{
	return(TimeVal(tv_sec, tv_nsec / 1000));
}
//	////////////////////////////////////////////////////////////////////////////

//	////////////////////////////////////////////////////////////////////////////
unsigned long long TimeSpec::ToTicks() const
{
	return(ToNanoseconds());
}
//	////////////////////////////////////////////////////////////////////////////

//	////////////////////////////////////////////////////////////////////////////
unsigned long long TimeSpec::ToNanoseconds() const
{
	return((static_cast<unsigned long long>(tv_sec) *
		static_cast<unsigned long long>(1000000000)) +
		static_cast<unsigned long long>(tv_nsec));
}
//	////////////////////////////////////////////////////////////////////////////

//	////////////////////////////////////////////////////////////////////////////
double TimeSpec::GetDoubleEquivalent() const
{
	return(static_cast<double>(tv_sec) +
		(static_cast<double>(tv_nsec) / 1000000000.0));
}
//	////////////////////////////////////////////////////////////////////////////

//	////////////////////////////////////////////////////////////////////////////
double TimeSpec::GetDoubleTicks() const
{
	return((static_cast<double>(tv_sec) * 1000000000.0) +
		static_cast<double>(tv_nsec));
}
//	////////////////////////////////////////////////////////////////////////////

//	////////////////////////////////////////////////////////////////////////////
signed long long TimeSpec::GetDifferenceTicks(const TimeSpec &time_1,
	const TimeSpec &time_2)
{
	return(static_cast<signed long long>(time_1.ToNanoseconds()) -
		static_cast<signed long long>(time_2.ToNanoseconds()));
}
//	////////////////////////////////////////////////////////////////////////////

//	////////////////////////////////////////////////////////////////////////////
double TimeSpec::GetDifferenceTicksDouble(const TimeSpec &time_1,
	const TimeSpec &time_2)
{
	return(time_1.GetDoubleTicks() - time_2.GetDoubleTicks());
}
//	////////////////////////////////////////////////////////////////////////////

//	////////////////////////////////////////////////////////////////////////////
double TimeSpec::GetDifferenceDouble(const TimeSpec &time_1,
	const TimeSpec &time_2)
{
	return(time_1.GetDoubleEquivalent() - time_2.GetDoubleEquivalent());
}
//	////////////////////////////////////////////////////////////////////////////

//	////////////////////////////////////////////////////////////////////////////
TimeSpec TimeSpec::GetDifference(const TimeSpec &time_1, const TimeSpec &time_2)
{
	signed long long tmp_value = GetDifferenceTicks(time_1, time_2);

	return(TimeSpec(static_cast<long>(tmp_value / 1000000000LL),
		static_cast<long>(tmp_value % 1000000000LL)));
}
//	////////////////////////////////////////////////////////////////////////////

//	////////////////////////////////////////////////////////////////////////////
TimeSpec TimeSpec::GetDifferenceAbs(const TimeSpec &time_1,
	const TimeSpec &time_2)
{
	return((time_1 >= time_2) ? GetDifference(time_1, time_2) :
		GetDifference(time_2, time_1));
}
//	////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
TimeSpec TimeSpec::FromString(const char *in_date)
{
	TimeSpec out_date(0, 0);

	ParseFromString(in_date, out_date.tv_sec, out_date.tv_nsec, 9);

	return(out_date);	
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
TimeSpec TimeSpec::FromString(const std::string &in_date)
{
	return(TimeSpec::FromString(in_date.c_str()));
}
// ////////////////////////////////////////////////////////////////////////////

//	////////////////////////////////////////////////////////////////////////////
TimeSpec TimeSpec::FromNanoseconds(unsigned long long nsecs)
{
	return(TimeSpec(static_cast<time_t>(nsecs /
		static_cast<unsigned long long>(1000000000)),
		static_cast<long>(nsecs % static_cast<unsigned long long>(1000000000))));
}
//	////////////////////////////////////////////////////////////////////////////

//	////////////////////////////////////////////////////////////////////////////
TimeSpec TimeSpec::Now()
{
	struct timespec out_time;

#ifdef __MSDOS__
	struct timeb struct_timeb;

	ftime(&struct_timeb);
	out_time.tv_sec  = struct_timeb.time;
	out_time.tv_nsec = ((long) struct_timeb.millitm) * 1000000L;
#elif _Windows
# ifdef __MINGW32__
	WIN32_FILETIME_64 sys_time;

	GetSystemTimeAsFileTime(&sys_time.struct_data);

	out_time.tv_sec  = ((long) ((sys_time.scalar_data -
		WIN32_FILETIME_EPOCH_BIAS) / 10000000LL));
	out_time.tv_nsec = ((long) ((sys_time.scalar_data * 100LL) %
		1000000000LL));
# else
	WIN32_FILETIME_64 sys_time;

	GetSystemTimeAsFileTime(&sys_time.struct_data);

	out_time.tv_sec  = ((long) ((sys_time.scalar_data -
		WIN32_FILETIME_EPOCH_BIAS) / 10000000i64));
	out_time.tv_nsec = ((long) ((sys_time.scalar_data * 100i64) %
		1000000000i64));
# endif // # ifdef __MINGW32__
#elif _POSIX_TIMERS
	clock_gettime(CLOCK_REALTIME, &out_time);
#else
	TimeVal tmp_timeval;

	::gettimeofday(&tmp_timeval, NULL);

	out_time.tv_sec  = tmp_timeval.tv_sec;
	out_time.tv_nsec = tmp_timeval.tv_usec * 1000L;
#endif // #ifdef __MSDOS__

	return(TimeSpec(out_time));
}
//	////////////////////////////////////////////////////////////////////////////

//	////////////////////////////////////////////////////////////////////////////
int TimeSpec::Compare(const TimeSpec *lhs, const TimeSpec *rhs)
{
	return(
		((int) (lhs->tv_sec  > rhs->tv_sec)  ?  1 :
				((lhs->tv_sec  < rhs->tv_sec)  ? -1 :
				((lhs->tv_nsec > rhs->tv_nsec) ?  1 :
				((lhs->tv_nsec < rhs->tv_nsec) ? -1 : 0)))));
}
//	////////////////////////////////////////////////////////////////////////////

//	////////////////////////////////////////////////////////////////////////////
TimeSpec TimeSpec::GetMinimumValue()
{
	TimeSpec tmp_datum(0, 0);

	return(tmp_datum.SetToMinimumValue());
}
//	////////////////////////////////////////////////////////////////////////////

//	////////////////////////////////////////////////////////////////////////////
TimeSpec TimeSpec::GetMaximumValue()
{
	TimeSpec tmp_datum(0, 0);

	return(tmp_datum.SetToMaximumValue());
}
//	////////////////////////////////////////////////////////////////////////////

//	////////////////////////////////////////////////////////////////////////////
char *TimeSpec::FormatString(const TimeTM &in_tm, char *buffer,
	unsigned int max_length) const
{
	if (max_length < Length_TimeSpec) {
		char tmp_buffer[Length_TimeSpec + 1];
		return(nstrcpy(buffer, FormatString(in_tm, tmp_buffer), max_length));
	}

	//	This gets YYYY-MM-DD hh:mm:ss
	in_tm.ToString(buffer);

	return(AppendFractionalPortion(Length_TimeT, buffer));
}
//	////////////////////////////////////////////////////////////////////////////

//	////////////////////////////////////////////////////////////////////////////
char *TimeSpec::FormatStringInterval(char *buffer,
	unsigned int max_length) const
{
	if (max_length < LengthInterval_TimeSpec) {
		char tmp_buffer[LengthInterval_TimeSpec + 1];
		return(nstrcpy(buffer, FormatStringInterval(tmp_buffer), max_length));
	}

	//	This gets dddddd hh:mm:ss
	TimeT tmp_time_t(tv_sec);
	tmp_time_t.ToStringInterval(buffer);

	return(AppendFractionalPortion(LengthInterval_TimeT, buffer));
}
//	////////////////////////////////////////////////////////////////////////////

//	////////////////////////////////////////////////////////////////////////////
char *TimeSpec::AppendFractionalPortion(unsigned int idx, char *buffer) const
{
	//	Sanity insurance
	unsigned long nsecs =
		static_cast<unsigned long>(this->tv_nsec) % 1000000000L;

	//	Now append the period followed by the number of nanoseconds
	buffer[idx++] = '.';
	buffer[idx++] = ((char) ('0' + ((char)  (nsecs /  100000000L))));
	buffer[idx++] = ((char) ('0' + ((char) ((nsecs % 100000000L) / 10000000L))));
	buffer[idx++] = ((char) ('0' + ((char) ((nsecs % 10000000L) / 1000000L))));
	buffer[idx++] = ((char) ('0' + ((char) ((nsecs % 1000000L) / 100000L))));
	buffer[idx++] = ((char) ('0' + ((char) ((nsecs % 100000L) / 10000L))));
	buffer[idx++] = ((char) ('0' + ((char) ((nsecs % 10000L) / 1000L))));
	buffer[idx++] = ((char) ('0' + ((char) ((nsecs % 1000L) / 100L))));
	buffer[idx++] = ((char) ('0' + ((char) ((nsecs % 100L) / 10L))));
	buffer[idx++] = ((char) ('0' + ((char)  (nsecs %  10L))));
	buffer[idx++] = '\0';

	return(buffer);
}
//	////////////////////////////////////////////////////////////////////////////

//	////////////////////////////////////////////////////////////////////////////
std::ostream & operator << (std::ostream &o_str, const TimeSpec &datum)
{
	char tmp_buffer[Length_TimeSpec + 1];

	o_str <<
		datum.ToString(tmp_buffer, sizeof(tmp_buffer) - 1);

	return(o_str);
}
//	////////////////////////////////////////////////////////////////////////////

} // namespace Utility

} // namespace MLB

