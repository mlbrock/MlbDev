// ////////////////////////////////////////////////////////////////////////////
// ////////////////////////////////////////////////////////////////////////////
//	MLB Utility Library Module File
// ////////////////////////////////////////////////////////////////////////////
/*
	File Name			:	DemangleCppName.cpp

	File Description	:	Implementation of the portable path name functions.

	Revision History	:	2015-07-20 --- Original logic implemented in file
													MlbDev/Utility/BackTrace.cpp.
									Michael L. Brock
								2016-08-07 --- Separated implementation into file
													DemangleCppName.cpp.
									Michael L. Brock

		Copyright Michael L. Brock 2015 - 2018.
		Distributed under the Boost Software License, Version 1.0.
		(See accompanying file LICENSE_1_0.txt or copy at
		http://www.boost.org/LICENSE_1_0.txt)

*/
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
// ////////////////////////////////////////////////////////////////////////////
//	Required include files...
// ////////////////////////////////////////////////////////////////////////////

#include <Utility/DemangleCppName.hpp>

#ifdef __linux__
# include <execinfo.h>
# include <cxxabi.h>
# include <boost/regex.hpp>
#endif // #ifdef __linux__

#include <boost/scoped_array.hpp>

// ////////////////////////////////////////////////////////////////////////////

namespace MLB {

namespace Utility {

// ////////////////////////////////////////////////////////////////////////////
std::string DemangleCppName(const char *src)
{
#if defined(__linux__)
	int                     status_code;
	boost::scoped_ptr<char> final_name(abi::__cxa_demangle(
		src, NULL, NULL, &status_code));

	return((!status_code) ? std::string(final_name.get()) :
		std::string(src));
#elif defined(_MSC_VER)
	return(src);
#else
	return(src);
#endif // #if defined(__linux__)
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
std::string DemangleCppName(const std::string &src)
{
	return(DemangleCppName(src.c_str()));
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
std::string DemangleTypeInfoName(const char *src)
{
	return(DemangleCppName(src));
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
std::string DemangleTypeInfoName(const std::string &src)
{
	return(DemangleTypeInfoName(src.c_str()));
}
// ////////////////////////////////////////////////////////////////////////////

} // namespace Utility

} // namespace MLB

// ////////////////////////////////////////////////////////////////////////////
//	****************************************************************************
//	****************************************************************************
//	****************************************************************************
// ////////////////////////////////////////////////////////////////////////////

#ifdef TEST_MAIN

// ////////////////////////////////////////////////////////////////////////////
#include <typeinfo>
// ////////////////////////////////////////////////////////////////////////////

using namespace MLB::Utility;

namespace {

// ////////////////////////////////////////////////////////////////////////////
struct MyStruct {
};
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
class MyClass {
public:
	struct MyStructInner {
	};
};
// ////////////////////////////////////////////////////////////////////////////

} // Anonymous namespace

// ////////////////////////////////////////////////////////////////////////////
int main()
{
	int return_code = EXIT_SUCCESS;

	try {
		std::cout << DemangleTypeInfoName(typeid(std::string).name()) << "\n";
		std::cout << DemangleTypeInfoName(typeid(std::ostream).name()) << "\n";
		std::cout << DemangleTypeInfoName(typeid(main).name()) << "\n";
		std::cout << DemangleTypeInfoName(typeid(MyStruct).name()) << "\n";
		std::cout << DemangleTypeInfoName(typeid(MyClass).name()) << "\n";
		std::cout << DemangleTypeInfoName(typeid(MyClass::MyStructInner).name())
			<< "\n";
	}
	catch (const std::exception &except) {
		std::cout << std::endl;
		std::cout << "Regression test error: " << except.what() << std::endl;
		return_code = EXIT_FAILURE;
	}

	return(return_code);
}
// ////////////////////////////////////////////////////////////////////////////

#endif // #ifdef TEST_MAIN

