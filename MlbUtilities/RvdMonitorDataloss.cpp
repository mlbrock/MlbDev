/*
===============================================================================
[_RV.INFO.SYSTEM.RVD.CONNECTED]
[{0}ADV_CLASS[TIBRVMSG_STRING](0)="INFO", {0}ADV_SOURCE[TIBRVMSG_STRING](0)="SYSTEM", {0}ADV_NAME[TIBRVMSG_STRING](0)="RVD.CONNECTED"]
-------------------------------------------------------------------------------
[_RV.INFO.SYSTEM.RVD.CONNECTED]
{0}[8=TIBRVMSG_STRING]ADV_CLASS(0)="INFO", {0}[8=TIBRVMSG_STRING]ADV_SOURCE(0)="SYSTEM", {0}[8=TIBRVMSG_STRING]ADV_NAME(0)="RVD.CONNECTED"
===============================================================================

===============================================================================
[_RV.WARN.SYSTEM.RVD.DISCONNECTED]
{0}[8=TIBRVMSG_STRING]ADV_CLASS(0)="WARN", {0}[8=TIBRVMSG_STRING]ADV_SOURCE(0)="SYSTEM", {0}[8=TIBRVMSG_STRING]ADV_NAME(0)="RVD.DISCONNECTED"
===============================================================================

===============================================================================
[_RV.INFO.SYSTEM.DAEMON.RESTARTED]
[{0}ADV_CLASS[TIBRVMSG_STRING](0)="INFO", {0}ADV_SOURCE[TIBRVMSG_STRING](0)="SYSTEM", {0}ADV_NAME[TIBRVMSG_STRING](0)="DAEMON.RESTARTED", {0}ADV_DESC[TIBRVMSG_STRING](0)="detected remote daemon restart", {0}host[TIBRVMSG_STRING](0)="159.55.246.116"]
-------------------------------------------------------------------------------
[_RV.INFO.SYSTEM.DAEMON.RESTARTED]
{0}[8=TIBRVMSG_STRING]ADV_CLASS(0)="INFO", {0}[8=TIBRVMSG_STRING]ADV_SOURCE(0)="SYSTEM", {0}[8=TIBRVMSG_STRING]ADV_NAME(0)="DAEMON.RESTARTED", {0}[8=TIBRVMSG_STRING]ADV_DESC(0)="detected remote daemon restart", {0}[8=TIBRVMSG_STRING]host(0)="159.55.246.120"
===============================================================================

[_RV.INFO.SYSTEM.HOST.START.9F37F654]
[{0}ADV_CLASS[TIBRVMSG_STRING](0)="INFO", {0}ADV_SOURCE[TIBRVMSG_STRING](0)="SYSTEM", {0}ADV_NAME[TIBRVMSG_STRING](0)="HOST.START.9F37F654", {0}hostaddr[TIBRVMSG_IPADDR32](0)=159.55.246.84, {0}sn[TIBRVMSG_U32](0)=222638, {0}os[TIBRVMSG_U8](0)=2, {0}ver[TIBRVMSG_STRING](0)="6.9.8", {0}httpaddr[TIBRVMSG_IPADDR32](0)=159.55.246.84, {0}httpport[TIBRVMSG_IPPORT16](0)=7580]

[_RV.INFO.SYSTEM.HOST.STOP.9F37F654]
[{0}ADV_CLASS[TIBRVMSG_STRING](0)="INFO", {0}ADV_SOURCE[TIBRVMSG_STRING](0)="SYSTEM", {0}ADV_NAME[TIBRVMSG_STRING](0)="HOST.STOP.9F37F654", {0}hostaddr[TIBRVMSG_IPADDR32](0)=159.55.246.84]

[_RV.INFO.SYSTEM.HOST.STATUS.AC1C4823]
[{0}ADV_CLASS[TIBRVMSG_STRING](0)="INFO", {0}ADV_SOURCE[TIBRVMSG_STRING](0)="SYSTEM", {0}ADV_NAME[TIBRVMSG_STRING](0)="HOST.STATUS.AC1C4823", {0}hostaddr[TIBRVMSG_IPADDR32](0)=172.28.72.35, {0}sn[TIBRVMSG_U32](0)=222638, {0}os[TIBRVMSG_U8](0)=2, {0}ver[TIBRVMSG_STRING](0)="6.9.8", {0}up[TIBRVMSG_U32](0)=2332848, {0}httpaddr[TIBRVMSG_IPADDR32](0)=172.28.72.35, {0}httpport[TIBRVMSG_IPPORT16](0)=7580, {0}ms[TIBRVMSG_U64](0)=530560, {0}bs[TIBRVMSG_U64](0)=546809790, {0}mr[TIBRVMSG_U64](0)=38683537, {0}br[TIBRVMSG_U64](0)=36180485133, {0}ps[TIBRVMSG_U64](0)=1428152, {0}pr[TIBRVMSG_U64](0)=86710702, {0}rx[TIBRVMSG_U64](0)=11315, {0}pm[TIBRVMSG_U64](0)=115487]
===============================================================================
[_RV.INFO.SYSTEM.RETRANSMISSION.INBOUND.EXPECTED]
[{0}ADV_CLASS[TIBRVMSG_STRING](0)="INFO", {0}ADV_SOURCE[TIBRVMSG_STRING](0)="SYSTEM", {0}ADV_NAME[TIBRVMSG_STRING](0)="RETRANSMISSION.INBOUND.EXPECTED", {0}ADV_DESC[TIBRVMSG_STRING](0)="gap in incoming sequence number stream: expecting retransmission", {0}host[TIBRVMSG_STRING](0)="159.55.246.205", {0}lost[TIBRVMSG_I32](0)=21]
-------------------------------------------------------------------------------
[_RV.INFO.SYSTEM.RETRANSMISSION.INBOUND.EXPECTED]
{0}[8=TIBRVMSG_STRING]ADV_CLASS(0)="INFO", {0}[8=TIBRVMSG_STRING]ADV_SOURCE(0)="SYSTEM", {0}[8=TIBRVMSG_STRING]ADV_NAME(0)="RETRANSMISSION.INBOUND.EXPECTED", {0}[8=TIBRVMSG_STRING]ADV_DESC(0)="gap in incoming sequence number stream: expecting retransmission", {0}[8=TIBRVMSG_STRING]host(0)="159.55.246.205", {0}[18=TIBRVMSG_I32]lost(0)=2
===============================================================================

===============================================================================
[_RV.INFO.SYSTEM.RETRANSMISSION.OUTBOUND.SENT]
[{0}ADV_CLASS[TIBRVMSG_STRING](0)="INFO", {0}ADV_SOURCE[TIBRVMSG_STRING](0)="SYSTEM", {0}ADV_NAME[TIBRVMSG_STRING](0)="RETRANSMISSION.OUTBOUND.SENT", {0}ADV_DESC[TIBRVMSG_STRING](0)="satisfying packet retransmission request", {0}host[TIBRVMSG_STRING](0)="172.28.72.45", {0}lost[TIBRVMSG_I32](0)=8]
-------------------------------------------------------------------------------
[_RV.INFO.SYSTEM.RETRANSMISSION.OUTBOUND.SENT]
{0}[8=TIBRVMSG_STRING]ADV_CLASS(0)="INFO", {0}[8=TIBRVMSG_STRING]ADV_SOURCE(0)="SYSTEM", {0}[8=TIBRVMSG_STRING]ADV_NAME(0)="RETRANSMISSION.OUTBOUND.SENT", {0}[8=TIBRVMSG_STRING]ADV_DESC(0)="satisfying packet retransmission request", {0}[8=TIBRVMSG_STRING]host(0)="159.55.246.182", {0}[18=TIBRVMSG_I32]lost(0)=200
===============================================================================

[_RV.INFO.SYSTEM.LISTEN.START.CATSDEV6.Reply.PmqManager.0.VAR_RESULTS.2gUp9O2jJaQ@1P6so93#cljQ.2EoGmT3aG1Wt01wvEJ05nn0@]
[{0}ADV_CLASS[TIBRVMSG_STRING](0)="INFO", {0}ADV_SOURCE[TIBRVMSG_STRING](0)="SYSTEM", {0}ADV_NAME[TIBRVMSG_STRING](0)="LISTEN.START.CATSDEV6.Reply.PmqManager.0.VAR_RESULTS.2gUp9O2jJaQ@1P6so93#cljQ.2EoGmT3aG1Wt01wvEJ05nn0@", {0}id[TIBRVMSG_STRING](0)="9F37F6CD.DAEMON.34846691CF61B5B618", {0}sub[TIBRVMSG_STRING](0)="CATSDEV6.Reply.PmqManager.0.VAR_RESULTS.2gUp9O2jJaQ@1P6so93#cljQ.2EoGmT3aG1Wt01wvEJ05nn0@", {0}refcnt[TIBRVMSG_I32](0)=1]

[_RV.INFO.SYSTEM.LISTEN.STOP.CATSDEV6.Reply.PmqManager.0.VAR_RESULTS.2gUp9O2jJaQ@1P6so93#cljQ.2EoGmT3aG1Wt01wvEJ05nn0@]
[{0}ADV_CLASS[TIBRVMSG_STRING](0)="INFO", {0}ADV_SOURCE[TIBRVMSG_STRING](0)="SYSTEM", {0}ADV_NAME[TIBRVMSG_STRING](0)="LISTEN.STOP.CATSDEV6.Reply.PmqManager.0.VAR_RESULTS.2gUp9O2jJaQ@1P6so93#cljQ.2EoGmT3aG1Wt01wvEJ05nn0@", {0}id[TIBRVMSG_STRING](0)="9F37F6CD.DAEMON.34846691CF61B5B618", {0}sub[TIBRVMSG_STRING](0)="CATSDEV6.Reply.PmqManager.0.VAR_RESULTS.2gUp9O2jJaQ@1P6so93#cljQ.2EoGmT3aG1Wt01wvEJ05nn0@", {0}refcnt[TIBRVMSG_I32](0)=0]

[_RV.INFO.SYSTEM.UNREACHABLE.TRANSPORT.9F37F6CD.DF4466D397258CDED0]
[{0}ADV_CLASS[TIBRVMSG_STRING](0)="INFO", {0}ADV_SOURCE[TIBRVMSG_STRING](0)="SYSTEM", {0}ADV_NAME[TIBRVMSG_STRING](0)="UNREACHABLE.TRANSPORT.9F37F6CD.DF4466D397258CDED0", {0}tport[TIBRVMSG_STRING](0)="9F37F6CD.DF4466D397258CDED0", {0}descr[TIBRVMSG_STRING](0)="PmqApi Client for CATSDEV6.VS_JOBS: HOST=uklogcp198, PID=3572, TID=7424"]

-------------------------------------------------------------------------------
159.55.246.101 UKLOWK670
[_RV.ERROR.SYSTEM.DATALOSS.INBOUND.BCAST]
[{0}ADV_CLASS[TIBRVMSG_STRING](0)="ERROR", {0}ADV_SOURCE[TIBRVMSG_STRING](0)="SYSTEM", {0}ADV_NAME[TIBRVMSG_STRING](0)="DATALOSS.INBOUND.BCAST", {0}ADV_DESC[TIBRVMSG_STRING](0)="dataloss: remote daemon already timed out the data", {0}host[TIBRVMSG_STRING](0)="159.55.246.115", {0}lost[TIBRVMSG_I32](0)=1]
-------------------------------------------------------------------------------
>>>>> Dispatcher started with TIBRV_NO_WAIT
[_RV.INFO.SYSTEM.DISPATCHER.THREAD_EXITED.dispatcher]
[message={0}ADV_CLASS(0)="INFO", {0}ADV_SOURCE(0)="SYSTEM", {0}ADV_NAME(0)="DISPATCHER.THREAD_EXITED.dispatcher", {0}status(0)=50, {0}description(0)="Operation timed out"}]
===============================================================================
subject=_RV.WARN.SYSTEM.LICENSE.EXPIRE, message=
{
{0}[8=TIBRVMSG_STRING]ADV_CLASS(0)="WARN", {0}[8=TIBRVMSG_STRING]ADV_SOURCE(0)="SYSTEM", {0}[8=TIBRVMSG_STRING]ADV_NAME(0)="LICENSE.EXPIRE", {0}[8=TIBRVMSG_STRING]ADV_DESC(0)="The license will expire", {0}[3=TIBRVMSG_DATETIME]expiretime(0)=2007-12-12 11:12:52.000000000
}
===============================================================================
*/

//	////////////////////////////////////////////////////////////////////////////
//	////////////////////////////////////////////////////////////////////////////
//	TibCo/Rendezvous Support Program
//	////////////////////////////////////////////////////////////////////////////
/*
	File Name  			:	%M%

	File Version      :	%I%

	Last Extracted		:	%D%	%T%

	Last Updated		:	%E%	%U%

	File Description	:	Implements scanning of Tib/Rendezvous daemons so as
								to monitor transmission problems.

	Revision History	:	2002-01-26 --- Creation
									Michael L. Brock

		Copyright Michael L. Brock 2002 - 2016.
		Distributed under the Boost Software License, Version 1.0.
		(See accompanying file LICENSE_1_0.txt or copy at
		http://www.boost.org/LICENSE_1_0.txt)

*/
//	////////////////////////////////////////////////////////////////////////////

//	////////////////////////////////////////////////////////////////////////////
//	////////////////////////////////////////////////////////////////////////////
//	Include necessary header files . . .
//	////////////////////////////////////////////////////////////////////////////

#include <Utility/InlineContainer.hpp>
#include <Utility/PathName.hpp>
#include <Utility/CriticalEventHandler.hpp>
#include <Utility/StringSupport.hpp>
#include <Utility/VersionNumber.hpp>
#include <Utility/ValueToStringRadix.hpp>
#include <Utility/LogManager.hpp>

#include <RvUtilX/RvParseCmdLineArg.hpp>
#include <RvUtilX/RvCallback.hpp>
#include <RvUtilX/GetRvField.hpp>

#include <SockLibX/SocketX.hpp>

#ifdef _Windows
# pragma warning(disable:4217 4668)
#endif // #ifdef _Windows

# include <boost/shared_array.hpp>
# include <boost/shared_ptr.hpp>

#ifdef _Windows
# pragma warning(default:4217 4668)
#endif // #ifdef _Windows

//	////////////////////////////////////////////////////////////////////////////

//	////////////////////////////////////////////////////////////////////////////
//	////////////////////////////////////////////////////////////////////////////
//	Defines the global logging objects...
//	////////////////////////////////////////////////////////////////////////////
LogManagerMacroDefinition(MB_LIB_LOCAL)
//	////////////////////////////////////////////////////////////////////////////

namespace MLB {
namespace RvUtilX {
//	////////////////////////////////////////////////////////////////////////////
template <typename DataType>
	std::string XXX_RvMsgFieldDataArrayToString(tibrv_u32 in_count,
	const void *in_list)
{
	const DataType     *tmp_list = static_cast<const DataType *>(in_list);
	unsigned int        count_1;
	std::ostringstream  out_string;

	out_string << "<" << in_count << ">";

	for (count_1 = 0; count_1 < in_count; ++count_1)
		out_string << ((count_1) ? ", " : "") <<
			"[" << count_1 << "]=" << tmp_list[count_1];

	return(out_string.str());
}
//	////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
std::string XXX_RvMsgFieldDataArrayToString(const TibrvMsgField &datum)
{
	std::string out_string;

	switch (datum.getType()) {
		case TIBRVMSG_I8ARRAY	:
			out_string = XXX_RvMsgFieldDataArrayToString<tibrv_i8>(
				datum.getCount(), datum.getData().array);
			break;
		case TIBRVMSG_U8ARRAY	:
			out_string = XXX_RvMsgFieldDataArrayToString<tibrv_u8>(
				datum.getCount(), datum.getData().array);
			break;
		case TIBRVMSG_I16ARRAY	:
			out_string = XXX_RvMsgFieldDataArrayToString<tibrv_i16>(
				datum.getCount(), datum.getData().array);
			break;
		case TIBRVMSG_U16ARRAY	:
			out_string = XXX_RvMsgFieldDataArrayToString<tibrv_u16>(
				datum.getCount(), datum.getData().array);
			break;
		case TIBRVMSG_I32ARRAY	:
			out_string = XXX_RvMsgFieldDataArrayToString<tibrv_i32>(
				datum.getCount(), datum.getData().array);
			break;
		case TIBRVMSG_U32ARRAY	:
			out_string = XXX_RvMsgFieldDataArrayToString<tibrv_u32>(
				datum.getCount(), datum.getData().array);
			break;
		case TIBRVMSG_I64ARRAY	:
			out_string = XXX_RvMsgFieldDataArrayToString<tibrv_i64>(
				datum.getCount(), datum.getData().array);
			break;
		case TIBRVMSG_U64ARRAY	:
			out_string = XXX_RvMsgFieldDataArrayToString<tibrv_u64>(
				datum.getCount(), datum.getData().array);
			break;
		case TIBRVMSG_F32ARRAY	:
			out_string = XXX_RvMsgFieldDataArrayToString<tibrv_f32>(
				datum.getCount(), datum.getData().array);
			break;
		case TIBRVMSG_F64ARRAY	:
			out_string = XXX_RvMsgFieldDataArrayToString<tibrv_f64>(
				datum.getCount(), datum.getData().array);
			break;
		default						:
			std::ostringstream error_text;
			error_text << "Unable to convert the specified non-array type ('" <<
				MsgFieldTypeToString(datum) <<
				"' to string with function 'XXX_RvMsgFieldDataArrayToString()'";
			throw RvException(error_text);
			break;
	}

	return(out_string);
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
std::string XXX_RvMsgFieldDataBytesToString(const TibrvMsgField &datum)
{
	std::ostringstream out_string;

	out_string << "<" << datum.getSize() << ">\"";

	if (datum.getSize()) {
		if (!memchr(datum.getData().buf, '\0', datum.getSize())) {
			std::string tmp_string(static_cast<const char *>(datum.getData().buf),
				datum.getSize());
			out_string << tmp_string;
		}
		else {
			unsigned int  tmp_len = datum.getSize();
			const char   *tmp_ptr = static_cast<const char *>(datum.getData().buf);
			unsigned int  count_1;
			for (count_1 = 0; count_1 < tmp_len; ++count_1) {
				if (std::isprint(static_cast<unsigned char>(*tmp_ptr)))
					out_string << *tmp_ptr;
				else
					out_string << "\\" << MLB::Utility::ValueToStringHex(
						static_cast<unsigned char>(*tmp_ptr));
				++tmp_ptr;
			}
		}
	}

	out_string << "\"";

	return(out_string.str());
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
std::string XXX_RvMsgFieldDataToString(const TibrvMsgField &datum)
{
	std::ostringstream out_string;

	out_string << datum.getName() << "[" << MsgFieldTypeToString(datum) <<
		"](" << datum.getId() << ")=";

	switch (datum.getType()) {
		case TIBRVMSG_NO_TAG		:
			out_string << MsgFieldTypeToString(datum);
			break;
		case TIBRVMSG_MSG			:
			out_string << "TIBRVMSG_MSG";
			break;
		case TIBRVMSG_DATETIME	:
			out_string << MLB::Utility::TimeSpec(
				static_cast<time_t>(datum.getData().date.sec),
				datum.getData().date.nsec);
			break;
		case TIBRVMSG_OPAQUE		:
			out_string << XXX_RvMsgFieldDataBytesToString(datum);
			break;
		case TIBRVMSG_STRING		:
			out_string << "\"" << datum.getData().str << "\"";
			break;
		case TIBRVMSG_BOOL		:
			out_string << ((datum.getData().boolean) ? "TRUE" : "FALSE");
			break;
		case TIBRVMSG_I8			:
			out_string << static_cast<int>(datum.getData().i8);
			break;
		case TIBRVMSG_U8			:
			out_string << static_cast<unsigned int>(datum.getData().u8);
			break;
		case TIBRVMSG_I16			:
			out_string << datum.getData().i16;
			break;
		case TIBRVMSG_U16			:
			out_string << datum.getData().u16;
			break;
		case TIBRVMSG_I32			:
			out_string << datum.getData().i32;
			break;
		case TIBRVMSG_U32			:
			out_string << datum.getData().u32;
			break;
		case TIBRVMSG_I64			:
			out_string << datum.getData().i64;
			break;
		case TIBRVMSG_U64			:
			out_string << datum.getData().u64;
			break;
		case TIBRVMSG_F32			:
			out_string << datum.getData().f32;
			break;
		case TIBRVMSG_F64			:
			out_string << datum.getData().f64;
			break;
		case TIBRVMSG_IPPORT16	:
			out_string << ntohs(datum.getData().ipport16);
			break;
		case TIBRVMSG_IPADDR32	:
			{
/*
				out_string <<
					static_cast<unsigned int>(reinterpret_cast<unsigned char *>(
						datum.getData().ipaddr32)[0]) << "." <<
					static_cast<unsigned int>(reinterpret_cast<unsigned char *>(
						datum.getData().ipaddr32)[1]) << "." <<
					static_cast<unsigned int>(reinterpret_cast<unsigned char *>(
						datum.getData().ipaddr32)[2]) << "." <<
					static_cast<unsigned int>(reinterpret_cast<unsigned char *>(
						datum.getData().ipaddr32)[3]);
*/
				tibrv_ipaddr32 ip_addr = datum.getData().ipaddr32;
				out_string <<
					static_cast<unsigned int>(reinterpret_cast<unsigned char *>(
						&ip_addr)[0]) << "." <<
					static_cast<unsigned int>(reinterpret_cast<unsigned char *>(
						&ip_addr)[1]) << "." <<
					static_cast<unsigned int>(reinterpret_cast<unsigned char *>(
						&ip_addr)[2]) << "." <<
					static_cast<unsigned int>(reinterpret_cast<unsigned char *>(
						&ip_addr)[3]);
			}
			break;
		case TIBRVMSG_ENCRYPTED	:
// CODE NOTE: To be implemented.
			out_string << "TIBRVMSG_ENCRYPTED";
			break;
		case TIBRVMSG_NONE		:
			out_string << MsgFieldTypeToString(datum);
			break;
		case TIBRVMSG_I8ARRAY	:
		case TIBRVMSG_U8ARRAY	:
		case TIBRVMSG_I16ARRAY	:
		case TIBRVMSG_U16ARRAY	:
		case TIBRVMSG_I32ARRAY	:
		case TIBRVMSG_U32ARRAY	:
		case TIBRVMSG_I64ARRAY	:
		case TIBRVMSG_U64ARRAY	:
		case TIBRVMSG_F32ARRAY	:
		case TIBRVMSG_F64ARRAY	:
			out_string << XXX_RvMsgFieldDataArrayToString(datum);
			break;
		case TIBRVMSG_XML			:
			out_string << XXX_RvMsgFieldDataBytesToString(datum);
			break;
		default						:
			out_string << MsgFieldTypeToString(datum);
			break;
	}

	return(out_string.str());
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
std::ostream & operator << (std::ostream &o_str, const TibrvMsgField &datum)
{
	o_str << XXX_RvMsgFieldDataToString(datum);

	return(o_str);
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
static void XXX_RvMsgToStringInternal(const TibrvMsg &msg, unsigned int depth,
	std::ostringstream &out_string)
{
	tibrv_u32 field_count;

	RvUtilX_THROW_TIBRV_STATUS_IF(msg.getNumFields,
		(field_count));

	tibrv_u32 count_1;
	for (count_1 = 0; count_1 < field_count; count_1++) {
		TibrvMsgField        msg_field;
		RvMsgSnapshotContext rvmsg_snapshot_context(msg);
		RvUtilX_THROW_TIBRV_STATUS_IF(const_cast<TibrvMsg &>(msg).getFieldByIndex,
			(msg_field, count_1));
		if (count_1)
			out_string << ", ";
		if (msg_field.getType() == TIBRVMSG_MSG)
			XXX_RvMsgToStringInternal(TibrvMsg(msg_field.getData().msg,
				TIBRV_FALSE), depth + 1, out_string);
		else
			out_string << "{" << depth << "}" <<
				XXX_RvMsgFieldDataToString(msg_field);
	}
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
void XXX_RvMsgToString(const TibrvMsg &msg, std::string &out_string)
{
	std::ostringstream tmp_string;

	XXX_RvMsgToStringInternal(msg, 0, tmp_string);

	out_string = tmp_string.str();
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
std::string XXX_RvMsgToString(const TibrvMsg &msg)
{
	std::string out_string;

	XXX_RvMsgToString(msg, out_string);

	return(out_string);
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
std::ostream & operator << (std::ostream &o_str, const TibrvMsg &datum)
{
	o_str << XXX_RvMsgToString(datum);

	return(o_str);
}
// ////////////////////////////////////////////////////////////////////////////
} // namespace RvUtilX
} // namespace MLB

namespace MLB {

namespace RvUtilX {

namespace RvInfo {

//	////////////////////////////////////////////////////////////////////////////
struct HostStatusMsg_Snapshot {
	HostStatusMsg_Snapshot()
		:hostaddr(0)
		,sn(0)
		,os(0)
		,ver(NULL)
		,up(0)
		,httpaddr(0)
		,httpport(0)
		,ms(0)
		,bs(0)
		,mr(0)
		,br(0)
		,ps(0)
		,pr(0)
		,rx(0)
		,pm(0)
	{
	}
	HostStatusMsg_Snapshot(const TibrvMsg &msg_recv)
		:hostaddr(ExtractField_hostaddr(msg_recv))
		,sn(ExtractField_sn(msg_recv))
		,os(ExtractField_os(msg_recv))
		,ver(ExtractField_ver(msg_recv))
		,up(ExtractField_up(msg_recv))
		,httpaddr(ExtractField_httpaddr(msg_recv))
		,httpport(ExtractField_httpport(msg_recv))
		,ms(ExtractField_ms(msg_recv))
		,bs(ExtractField_bs(msg_recv))
		,mr(ExtractField_mr(msg_recv))
		,br(ExtractField_br(msg_recv))
		,ps(ExtractField_ps(msg_recv))
		,pr(ExtractField_pr(msg_recv))
		,rx(ExtractField_rx(msg_recv))
		,pm(ExtractField_pm(msg_recv))
	{
	}

	static tibrv_ipaddr32 ExtractField_hostaddr(const TibrvMsg &msg_recv) {
		TibrvMsgField msg_field;
		ExtractField(msg_recv, "hostaddr", msg_field, TIBRVMSG_IPADDR32);
		return(msg_field.getData().ipaddr32);
	}
	static tibrv_u32       ExtractField_sn(const TibrvMsg &msg_recv) {
		TibrvMsgField msg_field;
		ExtractField(msg_recv, "sn", msg_field, TIBRVMSG_U32);
		return(msg_field.getData().u32);
	}
	static tibrv_u8        ExtractField_os(const TibrvMsg &msg_recv) {
		TibrvMsgField msg_field;
		ExtractField(msg_recv, "os", msg_field, TIBRVMSG_U8);
		return(msg_field.getData().u8);
	}
	static const char     *ExtractField_ver(const TibrvMsg &msg_recv) {
		TibrvMsgField msg_field;
		ExtractField(msg_recv, "ver", msg_field, TIBRVMSG_STRING);
		return(msg_field.getData().str);
	}
	static tibrv_u32       ExtractField_up(const TibrvMsg &msg_recv) {
		TibrvMsgField msg_field;
		ExtractField(msg_recv, "up", msg_field, TIBRVMSG_U32);
		return(msg_field.getData().u32);
	}
	static tibrv_ipaddr32  ExtractField_httpaddr(const TibrvMsg &msg_recv) {
		TibrvMsgField msg_field;
		ExtractField(msg_recv, "httpaddr", msg_field, TIBRVMSG_IPADDR32);
		return(msg_field.getData().ipaddr32);
	}
	static tibrv_ipport16  ExtractField_httpport(const TibrvMsg &msg_recv) {
		TibrvMsgField msg_field;
		ExtractField(msg_recv, "httpport", msg_field, TIBRVMSG_IPPORT16);
		return(::ntohs(msg_field.getData().ipport16));
	}
	static tibrv_u64       ExtractField_ms(const TibrvMsg &msg_recv) {
		TibrvMsgField msg_field;
		ExtractField(msg_recv, "ms", msg_field, TIBRVMSG_U64);
		return(msg_field.getData().u64);
	}
	static tibrv_u64       ExtractField_bs(const TibrvMsg &msg_recv) {
		TibrvMsgField msg_field;
		ExtractField(msg_recv, "bs", msg_field, TIBRVMSG_U64);
		return(msg_field.getData().u64);
	}
	static tibrv_u64       ExtractField_mr(const TibrvMsg &msg_recv) {
		TibrvMsgField msg_field;
		ExtractField(msg_recv, "mr", msg_field, TIBRVMSG_U64);
		return(msg_field.getData().u64);
	}
	static tibrv_u64       ExtractField_br(const TibrvMsg &msg_recv) {
		TibrvMsgField msg_field;
		ExtractField(msg_recv, "br", msg_field, TIBRVMSG_U64);
		return(msg_field.getData().u64);
	}
	static tibrv_u64       ExtractField_ps(const TibrvMsg &msg_recv) {
		TibrvMsgField msg_field;
		ExtractField(msg_recv, "ps", msg_field, TIBRVMSG_U64);
		return(msg_field.getData().u64);
	}
	static tibrv_u64       ExtractField_pr(const TibrvMsg &msg_recv) {
		TibrvMsgField msg_field;
		ExtractField(msg_recv, "pr", msg_field, TIBRVMSG_U64);
		return(msg_field.getData().u64);
	}
	static tibrv_u64       ExtractField_rx(const TibrvMsg &msg_recv) {
		TibrvMsgField msg_field;
		ExtractField(msg_recv, "rx", msg_field, TIBRVMSG_U64);
		return(msg_field.getData().u64);
	}
	static tibrv_u64       ExtractField_pm(const TibrvMsg &msg_recv) {
		TibrvMsgField msg_field;
		ExtractField(msg_recv, "pm", msg_field, TIBRVMSG_U64);
		return(msg_field.getData().u64);
	}

	static HostStatusMsg_Snapshot &ExtractMessage(const TibrvMsg &msg_recv,
		HostStatusMsg_Snapshot &host_status) {
		HostStatusMsg_Snapshot tmp_host_status(msg_recv);
		host_status = tmp_host_status;
		return(host_status);
	}
	static HostStatusMsg_Snapshot  ExtractMessage(const TibrvMsg &msg_recv) {
		HostStatusMsg_Snapshot host_status;
		return(ExtractMessage(msg_recv, host_status));
	}

	tibrv_ipaddr32  hostaddr;
	tibrv_u32       sn;						
	tibrv_u8        os;						//	??? Rvd=2, Rvrd=130
	const char     *ver;						//	Version 
	tibrv_u32       up;						//	Uptime
	tibrv_ipaddr32  httpaddr;
	tibrv_ipport16  httpport;
	tibrv_u64       ms;						//	Messages Sent
	tibrv_u64       bs;						//	Bytes Sent
	tibrv_u64       mr;						//	Messages Received
	tibrv_u64       br;						//	Bytes Received
	tibrv_u64       ps;						//	Packets Sent
	tibrv_u64       pr;						//	Packets Received
	tibrv_u64       rx;						//	Retransmission Requests
	tibrv_u64       pm;						//	Packets Missed

private:
	static TibrvMsgField &ExtractField(const TibrvMsg &msg_recv,
		const char *field_name, TibrvMsgField &msg_field,
		tibrv_u8 required_type = TIBRVMSG_NO_TAG, tibrv_u16 field_id = 0) {
		try {
			GetRvField(msg_recv, field_name, msg_field, field_id, true,
				required_type);
		}
		catch (const std::exception &except) {
			MLB::Utility::Rethrow(except, "Unable to extract a field in a "
				"Tib/Rv host status message: " + std::string(except.what()));
		}
		return(msg_field);
	}
};
//	////////////////////////////////////////////////////////////////////////////

#ifdef _Windows
# pragma warning(disable:4265 4275)
#endif // #ifdef _Windows
// ////////////////////////////////////////////////////////////////////////////
/*
struct RvdMonDLossHostCB : public TibrvMsgCallback {
	RvdMonDLossHostCB()
		:TibrvMsgCallback()
	{
	}

	void onMsg(TibrvListener *listener_ptr, TibrvMsg &msg_recv) {
		try {
			if (MLB::Utility::CriticalEventTest()) {
				listener_ptr->destroy();
				return;
			}
			const char *subject_name = GetSendSubjectPtr(msg_recv);
#if 0
			if ((!strcmp(subject_name, "_RV.INFO.SYSTEM.RVD.CONNECTED")) ||
				(!strncmp(subject_name, "_RV.INFO.SYSTEM.HOST.STATUS.",
				strlen("_RV.INFO.SYSTEM.HOST.STATUS."))) ||
				(!strncmp(subject_name, "_RV.INFO.SYSTEM.UNREACHABLE.TRANSPORT.",
				strlen("_RV.INFO.SYSTEM.UNREACHABLE.TRANSPORT."))) ||
				(!strncmp(subject_name, "_RV.INFO.SYSTEM.LISTEN.START.",
				strlen("_RV.INFO.SYSTEM.LISTEN.START."))) ||
				(!strncmp(subject_name, "_RV.INFO.SYSTEM.LISTEN.STOP.",
				strlen("_RV.INFO.SYSTEM.LISTEN.STOP."))))
				return;
#endif // #if 0
			if (strcmp(subject_name, "_RV.INFO.SYSTEM.RETRANSMISSION.INBOUND.EXPECTED") &&
				strcmp(subject_name, "_RV.INFO.SYSTEM.RETRANSMISSION.OUTBOUND.SENT"))
				return;
			LogInfo << "PROTOCOL MSG:[" << GetSendSubjectPtr(msg_recv) << "]" <<
				std::endl <<
			           "            :[" << XXX_RvMsgToString(msg_recv) << "]" <<
				std::endl;
		}
		catch (const std::exception &except) {
		}
		catch (...) {
		}
	}

private:
	MLB_Utility_NonCopyable_Macro(RvdMonDLossHostCB);
};
*/
// ////////////////////////////////////////////////////////////////////////////
#ifdef _Windows
# pragma warning(default:4265 4275)
#endif // #ifdef _Windows

//	////////////////////////////////////////////////////////////////////////////
//typedef boost::shared_ptr<ReplyInfoRvCb> ReplyInfoRvCbSPtr;
//	////////////////////////////////////////////////////////////////////////////

//	////////////////////////////////////////////////////////////////////////////
class RvdMonDLossHostImpl;
typedef boost::shared_ptr<RvdMonDLossHostImpl> RvdMonDLossHostImplSPtr;
//	////////////////////////////////////////////////////////////////////////////

//	////////////////////////////////////////////////////////////////////////////
class RvdMonDLossHostImpl {
	typedef boost::shared_ptr<TibrvQueue>        TibrvQueueSPtr;
	typedef boost::shared_ptr<TibrvNetTransport> TibrvNetTransportSPtr;
	typedef boost::shared_ptr<TibrvListener>     TibrvListenerSPtr;
//	typedef boost::shared_ptr<RvdMonDLossHostCB> RvdMonDLossHostCBSPtr;
	typedef boost::shared_ptr<RvCallbackMsgEvent<RvdMonDLossHostImpl> > RvdMonDLossHostImplCBSPtr;
	explicit RvdMonDLossHostImpl(unsigned int host_address = 0)
		:host_address_(static_cast<unsigned long>(host_address))
		,version_number_()
		,os_value_(0)
		,http_address_()
		,http_port_(0)
		,host_name_()
		,snd_spec_original_()
		,snd_spec_()
		,snd_spec_name_original_()
		,rv_queue_ptr_(new TibrvQueue)
		,transport_ptr_(new TibrvNetTransport)
		,listener_ptr_(new TibrvListener)
//		,callback_data_(new RvdMonDLossHostCB)
		,callback_data_(new RvCallbackMsgEvent<RvdMonDLossHostImpl>(GetThisRef()))
		,fmt_name_()
		,fmt_name_length_(0)
	{
	}
	RvdMonDLossHostImpl(const std::string &my_name, TibrvQueueGroup &queue_group,
		const SNDSpec &snd_spec, unsigned int host_address,
		const char *version_number = "", int os_value = 0,
		unsigned int http_address = 0, unsigned int http_port = 0)
		:host_address_(static_cast<unsigned long>(host_address))
		,version_number_(version_number)
		,os_value_(os_value)
		,http_address_(static_cast<unsigned long>(http_address))
		,http_port_(static_cast<unsigned int>(http_port))
		,host_name_()
		,snd_spec_original_(snd_spec)
		,snd_spec_(snd_spec)
		,snd_spec_name_original_()
		,rv_queue_ptr_(new TibrvQueue)
		,transport_ptr_(new TibrvNetTransport)
		,listener_ptr_(new TibrvListener)
//		,callback_data_(new RvdMonDLossHostCB)
		,callback_data_(new RvCallbackMsgEvent<RvdMonDLossHostImpl>(GetThisRef()))
		,fmt_name_()
		,fmt_name_length_(0)
	{
		snd_spec_original_.SetDaemon();
		snd_spec_name_original_ = snd_spec_original_.ToStringSimple();
		snd_spec_.SetDaemon(host_address_.GetHostIPAddress() + ":7500");
		snd_spec_.CreateTransport(*transport_ptr_);
		RvUtilX_THROW_TIBRV_STATUS_IF(transport_ptr_->setDescription,
			((my_name + ": Injected Transport").c_str()));
		//	Create the Tib/Rv message queue...
		RvUtilX_THROW_TIBRV_STATUS_IF(rv_queue_ptr_->create,
			());
		RvUtilX_THROW_TIBRV_STATUS_IF(rv_queue_ptr_->setLimitPolicy,
			(TIBRVQUEUE_DISCARD_NONE, 0, 0));
		RvUtilX_THROW_TIBRV_STATUS_IF(rv_queue_ptr_->setPriority,
			(2));
		RvUtilX_THROW_TIBRV_STATUS_IF(rv_queue_ptr_->setName,
			((my_name + ": Injected Queue").c_str()));
		RvUtilX_THROW_TIBRV_STATUS_IF(queue_group.add,
			(rv_queue_ptr_.get()));
		RvUtilX_THROW_TIBRV_STATUS_IF(listener_ptr_->create,
			(rv_queue_ptr_.get(), callback_data_.get(), transport_ptr_.get(),
//			"_RV.ERROR.SYSTEM.DATALOSS.>", this));
//			"_LOCAL.>", this));
			"_RV.>", this));
	}

public:

	static RvdMonDLossHostImplSPtr RvdMonDLossHostImplFactory(
		unsigned int host_address = 0) {
		return(RvdMonDLossHostImplSPtr(new RvdMonDLossHostImpl(host_address)));
	}
	static RvdMonDLossHostImplSPtr RvdMonDLossHostImplFactory(
		const std::string &my_name, TibrvQueueGroup &queue_group,
		const SNDSpec &snd_spec, unsigned int host_address,
		const char *version_number = "", int os_value = 0,
		unsigned int http_address = 0, unsigned int http_port = 0) {
		return(RvdMonDLossHostImplSPtr(new RvdMonDLossHostImpl(my_name,
			queue_group, snd_spec, host_address, version_number, os_value,
			http_address,http_port)));
	}

	bool operator < (const RvdMonDLossHostImpl &other) const {
		return(host_address_ < other.host_address_);
	}

	const std::string              &GetHostNameRef() const {
		return(ResolveHostName());
	}
	const MLB::SockLibX::AddressIP &GetHostAddrRef() const {
		return(host_address_);
	}
	const std::string              &GetVersionNumberRef() const {
		return(version_number_);
	}

	std::string ToStringBasic() const {
		std::ostringstream o_str;
		o_str << std::setw(5 + 1 + 15 + 1) << snd_spec_name_original_<< " " <<
			std::setw(15) << host_address_ << " " << GetHostNameRef();
		return(o_str.str());
	}
	std::string ToStringBasicFormatted() const {
		std::ostringstream o_str;
		o_str << std::setw(10) << version_number_ << " " << std::setw(15) <<
			host_address_ << " " << std::left << std::setw(64) <<
			GetHostNameRef();
		return(o_str.str());
	}
	std::string ToStringFormatted() const {
/*
		std::ostringstream o_str;
		o_str << std::setw(10) << version_number_ << " " << std::setw(15) <<
			host_address_ << " " << std::left << std::setw(64) <<
			GetHostNameRef() << " (HTTP Access: " <<
			MLB::SockLibX::EndPointIP(http_address_, http_port_) << ")";
		return(o_str.str());
*/
		std::ostringstream o_str;
		o_str << ToStringBasicFormatted() << " (HTTP Access: " <<
			MLB::SockLibX::EndPointIP(http_address_, http_port_) << ")";
		return(o_str.str());
	}

	bool IsVersionChange(const char *new_version_number) const {
		return(version_number_ != new_version_number);
	}

/*
	RvdMonDLossHostImpl &ApplyMessage(const TibrvMsg &msg_recv);
*/

	MLB::SockLibX::AddressIP  host_address_;
	std::string               version_number_;
	int                       os_value_;
	MLB::SockLibX::AddressIP  http_address_;
	unsigned int              http_port_;
	mutable std::string       host_name_;		//	Lazily-populated, hence mutable.
	SNDSpec                   snd_spec_original_;
	SNDSpec                   snd_spec_;
	std::string               snd_spec_name_original_;
	TibrvQueueSPtr            rv_queue_ptr_;
	TibrvNetTransportSPtr     transport_ptr_;
	TibrvListenerSPtr         listener_ptr_;
	RvdMonDLossHostImplCBSPtr callback_data_;
	std::string               fmt_name_;
	unsigned int              fmt_name_length_;

	const std::string &GetFormattedNameRef() {
		if (fmt_name_.empty()) {
			fmt_name_        = ToStringBasic();
			fmt_name_length_ = static_cast<unsigned int>(fmt_name_.size());
		}
		return(fmt_name_);
	}
	unsigned int       GetFormattedNameLength() {
		if (fmt_name_.empty())
			GetFormattedNameRef();
		return(fmt_name_length_);
	}

	void ReportException(const std::exception *except_ptr) {
		LogError << "Exception encountered in Tib/Rendezvous callback: " <<
			((except_ptr != NULL) ? except_ptr->what() : "*UNSPECIFIED*") <<
			std::endl;
	}

	void ProcessEventOnMsg(TibrvMsgCallback *callback_ptr,
		TibrvListener *listener, TibrvMsg &msg_recv) {
			const char *subject_name = GetSendSubjectPtr(msg_recv);
		if ((!strcmp(subject_name, "_RV.INFO.SYSTEM.RVD.CONNECTED")) ||
			(!strcmp(subject_name, "_RV.INFO.SYSTEM.RETRANSMISSION.INBOUND.EXPECTED")) ||
			(!strcmp(subject_name, "_RV.INFO.SYSTEM.RETRANSMISSION.OUTBOUND.SENT")) ||
			(!strcmp(subject_name, "_RV.INFO.SYSTEM.DAEMON.RESTARTED")) ||
			(!strncmp(subject_name, "_RV.INFO.SYSTEM.HOST.STATUS.",
			strlen("_RV.INFO.SYSTEM.HOST.STATUS."))) ||
			(!strncmp(subject_name, "_RV.INFO.SYSTEM.UNREACHABLE.TRANSPORT.",
			strlen("_RV.INFO.SYSTEM.UNREACHABLE.TRANSPORT."))) ||
			(!strncmp(subject_name, "_RV.INFO.SYSTEM.HOST.START.",
			strlen("_RV.INFO.SYSTEM.HOST.START."))) ||
			(!strncmp(subject_name, "_RV.INFO.SYSTEM.HOST.STOP.",
			strlen("_RV.INFO.SYSTEM.HOST.STOP."))) ||
			(!strncmp(subject_name, "_RV.INFO.SYSTEM.LISTEN.START.",
			strlen("_RV.INFO.SYSTEM.LISTEN.START."))) ||
			(!strncmp(subject_name, "_RV.INFO.SYSTEM.LISTEN.STOP.",
			strlen("_RV.INFO.SYSTEM.LISTEN.STOP."))))
			return;
		LogInfo << "PROTOCOL MSG: " << GetFormattedNameRef() << ": " <<
			"[" << subject_name << "]" <<
			std::endl <<
		           "            : " << std::setw(GetFormattedNameLength()) <<
			"" << ": " << XXX_RvMsgToString(msg_recv) << "]" <<
			std::endl;
	}

private:
	MLB_Utility_NonCopyable_Macro(RvdMonDLossHostImpl);

	RvdMonDLossHostImpl &GetThisRef() {
		return(*this);
	}

	std::string &ResolveHostName() const {
		if (host_name_.empty()) {
			try {
				MLB::SockLibX::ResolveHostToName(host_address_.ToString(),
					host_name_);
			}
			catch (const std::exception &) {
				host_name_ = "UNABLE.TO.RESOLVE.HOST";
			}
		}
		return(host_name_);
	}
};
//	////////////////////////////////////////////////////////////////////////////

//	////////////////////////////////////////////////////////////////////////////
//	////////////////////////////////////////////////////////////////////////////

//	////////////////////////////////////////////////////////////////////////////
class RvdMonDLossHost {
public:
	explicit RvdMonDLossHost(unsigned int host_address = 0)
		:impl_ptr_(RvdMonDLossHostImpl::RvdMonDLossHostImplFactory(host_address))
	{
	}
	RvdMonDLossHost(const std::string &my_name, TibrvQueueGroup &queue_group,
		const SNDSpec &snd_spec, unsigned int host_address,
		const char *version_number = "", int os_value = 0,
		unsigned int http_address = 0, unsigned int http_port = 0)
		:impl_ptr_(RvdMonDLossHostImpl::RvdMonDLossHostImplFactory(my_name,
			queue_group, snd_spec, host_address, version_number, os_value,
			http_address, http_port))
	{
	}

	bool operator < (const RvdMonDLossHost &other) const {
		return(impl_ptr_->host_address_ < other.impl_ptr_->host_address_);
	}

	const std::string              &GetHostNameRef() const {
		return(impl_ptr_->GetHostNameRef());
	}
	const MLB::SockLibX::AddressIP &GetHostAddrRef() const {
		return(impl_ptr_->GetHostAddrRef());
	}
	const std::string              &GetVersionNumberRef() const {
		return(impl_ptr_->GetVersionNumberRef());
	}

	std::string ToStringBasicFormatted() const {
		return(impl_ptr_->ToStringBasicFormatted());
	}
	std::string ToStringFormatted() const {
		return(impl_ptr_->ToStringFormatted());
	}

	bool IsVersionChange(const char *new_version_number) const {
		return(impl_ptr_->IsVersionChange(new_version_number));
	}

	RvdMonDLossHostImplSPtr impl_ptr_;
};
//	////////////////////////////////////////////////////////////////////////////

//	////////////////////////////////////////////////////////////////////////////
typedef std::set<RvdMonDLossHost>          RvdMonDLossHostSet;
typedef RvdMonDLossHostSet::iterator       RvdMonDLossHostSetIter;
typedef RvdMonDLossHostSet::const_iterator RvdMonDLossHostSetIterC;
//	////////////////////////////////////////////////////////////////////////////

//	////////////////////////////////////////////////////////////////////////////
/*
RvdMonDLossHost &RvdMonDLossHost::ApplyMessage(const TibrvMsg &msg_recv)
{
	host_address_   = MLB::SockLibX::AddressIP(static_cast<unsigned long>(
		HostStatusMsg_Snapshot::ExtractField_hostaddr(msg_recv)));
	version_number_ = HostStatusMsg_Snapshot::ExtractField_ver(msg_recv);
	os_value_       = HostStatusMsg_Snapshot::ExtractField_os(msg_recv);
	http_address_   = MLB::SockLibX::AddressIP(static_cast<unsigned long>(
		HostStatusMsg_Snapshot::ExtractField_httpaddr(msg_recv)));
	http_port_      = HostStatusMsg_Snapshot::ExtractField_httpport(msg_recv);
	host_name_.clear();

	return(*this);
}
*/
//	////////////////////////////////////////////////////////////////////////////

//	////////////////////////////////////////////////////////////////////////////
class RvdMonDLossService {
public:
	RvdMonDLossService(const SNDSpec &snd_spec);

	bool operator < (const RvdMonDLossService &other) const;

	void ApplyMessage(const std::string &my_name, TibrvQueueGroup &queue_group, 
		const MLB::Utility::StringSet &versions_set,
		unsigned int longest_snd_spec, const TibrvMsg &msg_recv,
		unsigned int &bad_count);

	int                                  service_id_;
	SNDSpec                              snd_spec_;
	std::string                          snd_spec_name_;
	boost::shared_ptr<TibrvNetTransport> transport_ptr_;
	RvdMonDLossHostSet                   host_set_;
};
//	////////////////////////////////////////////////////////////////////////////

//	////////////////////////////////////////////////////////////////////////////
typedef std::set<RvdMonDLossService>          RvdMonDLossServiceSet;
typedef RvdMonDLossServiceSet::iterator       RvdMonDLossServiceSetIter;
typedef RvdMonDLossServiceSet::const_iterator RvdMonDLossServiceSetIterC;
//	////////////////////////////////////////////////////////////////////////////

//	////////////////////////////////////////////////////////////////////////////
RvdMonDLossService::RvdMonDLossService(const SNDSpec &snd_spec)
	:service_id_(::atoi(snd_spec.service_.c_str()))
	,snd_spec_(snd_spec)
	,snd_spec_name_(snd_spec.ToStringSimple())
	,transport_ptr_(new TibrvNetTransport)
	,host_set_()
{
}
//	////////////////////////////////////////////////////////////////////////////

//	////////////////////////////////////////////////////////////////////////////
bool RvdMonDLossService::operator < (const RvdMonDLossService &other) const
{
	int cmp = service_id_ - other.service_id_;

	return((cmp < 0) ? true : ((cmp > 0) ? false :
		(snd_spec_ < other.snd_spec_)));
}
//	////////////////////////////////////////////////////////////////////////////

//	////////////////////////////////////////////////////////////////////////////
void RvdMonDLossService::ApplyMessage(const std::string &my_name,
	TibrvQueueGroup &queue_group, const MLB::Utility::StringSet &versions_set,
	unsigned int longest_snd_spec, const TibrvMsg &msg_recv,
	unsigned int &bad_count)
{
	tibrv_ipaddr32  hostaddr =
		HostStatusMsg_Snapshot::ExtractField_hostaddr(msg_recv);
	const char     *ver       =
		HostStatusMsg_Snapshot::ExtractField_ver(msg_recv);

	bool version_is_ok = (versions_set.empty() ||
		(versions_set.find(ver) != versions_set.end()));

	RvdMonDLossHostSetIter iter_f(
										host_set_.find(RvdMonDLossHost(hostaddr)));

	if (iter_f == host_set_.end()) {
		HostStatusMsg_Snapshot host_status;
		HostStatusMsg_Snapshot::ExtractMessage(msg_recv, host_status);
		RvdMonDLossHost new_host(my_name, queue_group, snd_spec_,
			host_status.hostaddr, host_status.ver, host_status.os,
			host_status.httpaddr, host_status.httpport);
		iter_f = host_set_.insert(new_host).first;
		bad_count += (version_is_ok) ? 0 : 1;
		if (version_is_ok)
			LogDetail << "New host, version ok        : " << std::left <<
				std::setw(longest_snd_spec) << snd_spec_name_ << " " <<
				iter_f->ToStringFormatted() << std::endl;
		else
			LogWarning << "New host, version invalid   : " << std::left <<
				std::setw(longest_snd_spec) << snd_spec_name_ << " " <<
				iter_f->ToStringFormatted() << std::endl;
	}
	else if (iter_f->IsVersionChange(ver)) {
		if (version_is_ok) {
			LogDetail << "Host change, version ok      : " << std::left <<
				std::setw(longest_snd_spec) << snd_spec_name_ << " " <<
				iter_f->ToStringFormatted() << std::endl;
			--bad_count;
		}
		else {
			LogWarning << "Host change, version invalid: " << std::left <<
				std::setw(longest_snd_spec) << snd_spec_name_ << " " <<
				iter_f->ToStringFormatted() << std::endl;
			++bad_count;
		}
	}
	else
		LogDebug << "Host heartbeat, no change      : " << std::left <<
				std::setw(longest_snd_spec) << snd_spec_name_ << " " <<
				iter_f->ToStringFormatted() << std::endl;
}
//	////////////////////////////////////////////////////////////////////////////

//	////////////////////////////////////////////////////////////////////////////
class RvdMonDLossRecap {
public:
	RvdMonDLossRecap(const RvdMonDLossService &service_ref,
		const RvdMonDLossHost &host_ref)
		:service_ptr_(&service_ref)
		,host_ptr_(&host_ref)
	{
	}

	bool operator < (const RvdMonDLossRecap &other) const {
		int cmp =
			host_ptr_->GetVersionNumberRef().compare(other.host_ptr_->GetVersionNumberRef());
		if (cmp)
			return(cmp < 0);
		cmp = service_ptr_->snd_spec_.ToStringSimple().compare(
			other.service_ptr_->snd_spec_.ToStringSimple());
		if (cmp)
			return(cmp < 0);
		return(host_ptr_->GetHostNameRef().compare(
			other.host_ptr_->GetHostNameRef()) < 0);
	}

	std::string ToString(unsigned int longest_snd_spec) const {
		std::ostringstream o_str;
		o_str << std::setw(10) << host_ptr_->GetVersionNumberRef() << " " <<
			std::setw(longest_snd_spec) << service_ptr_->snd_spec_name_ << " " <<
			std::setw(15) << host_ptr_->GetHostAddrRef() << " " <<
			host_ptr_->GetHostNameRef();
		return(o_str.str());
	}

	static void EmitRecap(const RvdMonDLossServiceSet &service_set,
		unsigned int longest_snd_spec);

	const RvdMonDLossService *service_ptr_;
	const RvdMonDLossHost    *host_ptr_;
};
//	////////////////////////////////////////////////////////////////////////////

//	////////////////////////////////////////////////////////////////////////////
void RvdMonDLossRecap::EmitRecap(const RvdMonDLossServiceSet &service_set,
	unsigned int longest_snd_spec)
{
	typedef std::set<RvdMonDLossRecap>          RvdMonDLossRecapSet;
	typedef RvdMonDLossRecapSet::const_iterator RvdMonDLossRecapSetIterC;

	RvdMonDLossRecapSet        recap_set;
	RvdMonDLossServiceSetIterC iter_s_b(service_set.begin());
	RvdMonDLossServiceSetIterC iter_s_e(service_set.end());

	for ( ; iter_s_b != iter_s_e; ++iter_s_b) {
		RvdMonDLossHostSetIterC iter_h_b(iter_s_b->host_set_.begin());
		RvdMonDLossHostSetIterC iter_h_e(iter_s_b->host_set_.end());
		for ( ; iter_h_b != iter_h_e; ++iter_h_b)
			recap_set.insert(RvdMonDLossRecap(*iter_s_b, *iter_h_b));
	}

	LogInfo.LogSeparator('-');

	RvdMonDLossRecapSetIterC iter_r_b(recap_set.begin());
	RvdMonDLossRecapSetIterC iter_r_e(recap_set.end());

	for ( ; iter_r_b != iter_r_e; ++iter_r_b)
		LogInfo << "Version Number Recap: " <<
			iter_r_b->ToString(longest_snd_spec) << std::endl;
}
//	////////////////////////////////////////////////////////////////////////////

//	////////////////////////////////////////////////////////////////////////////
class RvdMonDLoss {
public:
	RvdMonDLoss()
		:rv_context_()
		,version_number_(1, 0, 0, 0)
		,service_set_()
		,valid_versions_set_()
		,log_flag_(true)
		,log_dir_("./")
		,queue_group_()
		,queue_()
		,listener_list_()
		,callback_data_(GetThisRef())
		,timer_()
		,callback_timer_(GetThisRef())
		,timer_count_(-1)
		,longest_snd_spec_(0)
		,bad_count_(0)
		,heartbeat_count_(0)
	{
	}

	void ParseCmdLine(int argc, char **argv);
	void Start();
	void DetermineServiceList();
	void Run();

	RvContext                                         rv_context_;
	std::string                                       my_name_;
	MLB::Utility::VersionNumber                       version_number_;
	RvdMonDLossServiceSet                             service_set_;
	MLB::Utility::StringSet                           valid_versions_set_;
	bool                                              log_flag_;
	std::string                                       log_dir_;
	TibrvQueueGroup                                   queue_group_;
	TibrvQueue                                        queue_;
	std::deque<boost::shared_ptr<TibrvListener> >     listener_list_;
	MLB::RvUtilX::RvCallbackMsgEvent<RvdMonDLoss>     callback_data_;
	TibrvTimer                                        timer_;
	MLB::RvUtilX::RvCallbackTimerEvent<RvdMonDLoss>   callback_timer_;
	int                                               timer_count_;
	unsigned int                                      longest_snd_spec_;
	unsigned int                                      bad_count_;
	unsigned long long                                heartbeat_count_;

	void ProcessEventOnMsg(TibrvMsgCallback *call_back_ptr,
		TibrvListener *listener_ptr, TibrvMsg &msg_recv);
	void ProcessEventOnTimer(TibrvTimerCallback *callback_ptr,
		TibrvTimer *timer_ptr);
	void ReportException(const std::exception *except_ptr);

private:
	MLB_Utility_NonCopyable_Macro(RvdMonDLoss);

	RvdMonDLoss &GetThisRef() {
		return(*this);
	}

	void StartInternal();
	void EmitStatus() const;
};
//	////////////////////////////////////////////////////////////////////////////

//	////////////////////////////////////////////////////////////////////////////
void RvdMonDLoss::ParseCmdLine(int argc, char **argv)
{
	unsigned int count_1;
	SNDSpec      snd_template;

	for (count_1 = 1; count_1 < static_cast<unsigned int>(argc); ++count_1) {
		std::string tmp_string;
		if (RvParseCmdLineArg::ParseCmdLineCombinedServiceNetwork(count_1, argc,
			argv, snd_template))
			service_set_.insert(RvdMonDLossService(snd_template));
		else if (RvParseCmdLineArg::ParseCmdLineDaemon(count_1, argc,
			argv, snd_template.daemon_))
			;
		else if (RvParseCmdLineArg::ParseCmdLineFollowingSpec(
			MLB::Utility::MakeInlineVector<std::string>
			("-VALID_VERSIONS")
			("-VALIDVERSIONS")
			("-VALID_VERSION")
			("-VALIDVERSION")
			("-VALID_VERS")
			("-VALIDVERS")
			("-VALID_VER")
			("-VALIDVER"),
			count_1, argc, argv, tmp_string)) {
			MLB::Utility::StringVector tmp_list;
			MLB::Utility::SplitString(tmp_string, ",", tmp_list, 0, true);
			MLB::Utility::StringVectorIter iter_b(tmp_list.begin());
			MLB::Utility::StringVectorIter iter_e(tmp_list.end());
			for ( ; iter_b != iter_e ; ++iter_b) {
				if (!iter_b->empty())
					valid_versions_set_.insert(MLB::Utility::UpperCase(*iter_b));
			}
		}
		else if (RvParseCmdLineArg::ParseLoggingFlag(count_1, argc, argv,
			log_flag_))
			;
		else if (RvParseCmdLineArg::ParseLoggingDir(count_1, argc, argv,
			log_dir_, "", true))
			;
		else
			RvParseCmdLineArg::InvalidArgument(argv[count_1]);
	}

	//	If no services have been specified, use the default Tib/Rv one...
	if (service_set_.empty())
		service_set_.insert(RvdMonDLossService(SNDSpec()));

	//	Ensure logging directory is fully resolved...
	if (log_flag_)
		MLB::Utility::ResolveDirectoryPath(log_dir_, "", true);
}
//	////////////////////////////////////////////////////////////////////////////

//	////////////////////////////////////////////////////////////////////////////
void RvdMonDLoss::Start()
{
	MLB::Utility::TimeVal start_up_time;

	my_name_ = "RvdMonitorDataloss on host " +
		MLB::Utility::GetHostNameCanonical() + ", PID " +
		MLB::Utility::AnyToString(MLB::Utility::CurrentProcessId());

	//	//////////////////////////////////////////////////////////////////////
	//	//////////////////////////////////////////////////////////////////////
	//	Start-up logging...
	//	//////////////////////////////////////////////////////////////////////
	std::string log_file_name;
	try {
		MyLogManager.SetLogLevelConsole(MLB::Utility::LogLevel_Info);
		MyLogManager.SetLogLevelFile(MLB::Utility::LogLevel_Detail);
		if (log_flag_) {
			std::string tmp_date_time(start_up_time.ToTimeT().ToString());
			tmp_date_time[10]  = '.';
			tmp_date_time[13]  = '.';
			tmp_date_time[16]  = '.';
			log_file_name = log_dir_ + "/RvdMonDLossitor." + tmp_date_time +
				"." + MLB::Utility::GetHostNameCanonical() + "." +
				MLB::Utility::AnyToString(MLB::Utility::CurrentProcessId()) +
				".log";
			boost::shared_ptr<MLB::Utility::LogHandlerFile>
				my_log_handler(new MLB::Utility::LogHandlerFile(log_file_name,
					MLB::Utility::LogHandlerFile::None));
			MyLogManager.HandlerInstall(my_log_handler);
		}
	}
	catch (const std::exception &except) {
		MLB::Utility::Rethrow(except, "Unable to install logging facility: " +
			std::string(except.what()));
	}
	//	//////////////////////////////////////////////////////////////////////

	LogInfo.LogSeparator('=');
	LogInfo.LogSeparator('=');

	LogInfo << "Program Name      : RvdMonDLossitor" << std::endl;
	LogInfo << "Program Version   : " << version_number_ << std::endl;
	LogInfo << "Host Name         : " <<
		MLB::Utility::GetHostNameCanonical() << std::endl;
	LogInfo << "Process Id        : " <<
		MLB::Utility::CurrentProcessId() << std::endl;
	LogInfo << "Logging Flag      : " <<
		MLB::Utility::AnyToString(log_flag_) << std::endl;
	LogInfo << "Logging Directory : " <<
		((log_flag_) ? log_dir_ : "N/A") << std::endl;
	LogInfo << "Logging File      : " <<
		((log_flag_) ? log_file_name : "N/A") << std::endl;

	LogInfo.LogSeparator('-');

	//	Log information about the Tib/Rv services covered...
	{
		RvdMonDLossServiceSetIterC iter_b(service_set_.begin());
		RvdMonDLossServiceSetIterC iter_e(service_set_.end());
		for ( ; iter_b != iter_e ; ++iter_b) {
			LogInfo << ((iter_b == service_set_.begin()) ?
				"Rendezvous Service: " : "                  : ") <<
				iter_b->snd_spec_ << std::endl;
			longest_snd_spec_ = std::max(longest_snd_spec_,
				static_cast<unsigned int>(iter_b->snd_spec_name_.size()));
		}
	}

	LogInfo.LogSeparator('=');

	try {
		StartInternal();
	}
	catch (const std::exception &except) {
		LogError << except.what() << std::endl;
	}

	if (!service_set_.empty()) {
		LogInfo.LogSeparator('=');
		try {
			RvdMonDLossRecap::EmitRecap(service_set_, longest_snd_spec_);
		}
		catch (const std::exception &except) {
			LogError << "Unable to produce the version number recap: " <<
				except.what() << std::endl;
		}
		LogInfo.LogSeparator('=');
	}

	LogInfo << "Exiting program..." << std::endl;

	LogInfo.LogSeparator('=');
	LogInfo << "End of Log File" << std::endl;
	LogInfo.LogSeparator('=');
	LogInfo.LogSeparator('=');
}
//	////////////////////////////////////////////////////////////////////////////

//	////////////////////////////////////////////////////////////////////////////
void RvdMonDLoss::StartInternal()
{
	RvUtilX_THROW_TIBRV_STATUS_IF(queue_group_.create,
		());

	//	Create the Tib/Rv message queue...
	RvUtilX_THROW_TIBRV_STATUS_IF(queue_.create,
		());
	RvUtilX_THROW_TIBRV_STATUS_IF(queue_.setLimitPolicy,
		(TIBRVQUEUE_DISCARD_NONE, 0, 0));
	RvUtilX_THROW_TIBRV_STATUS_IF(queue_.setPriority,
		(2));
	RvUtilX_THROW_TIBRV_STATUS_IF(queue_.setName,
		((my_name_ + ": Queue").c_str()));

	RvUtilX_THROW_TIBRV_STATUS_IF(queue_group_.add,
		(&queue_));

	//	Create a transport for of the Tib/Rv services covered...
	RvdMonDLossServiceSetIterC iter_b(service_set_.begin());
	RvdMonDLossServiceSetIterC iter_e(service_set_.end());

	for ( ; iter_b != iter_e ; ++iter_b) {
		//	Create the transport...
		iter_b->snd_spec_.CreateTransport(*iter_b->transport_ptr_);
		//	Give it a descriptive name...
		RvUtilX_THROW_TIBRV_STATUS_IF(iter_b->transport_ptr_->setDescription,
			((my_name_ + ": Transport").c_str()));
		//	Create the listener...
		boost::shared_ptr<TibrvListener> the_listener(new TibrvListener);
		//	Bind the listener to its transport... Note that we use a pointer
		//	to the RvdMonDLossService instance as the closure...
		RvUtilX_THROW_TIBRV_STATUS_IF(the_listener->create,
			(&queue_, &callback_data_, iter_b->transport_ptr_.get(),
			"_RV.INFO.SYSTEM.HOST.STATUS.>", &(*iter_b)));
		listener_list_.push_back(the_listener);
	}

	//	Add the interval timer event...
	RvUtilX_THROW_TIBRV_STATUS_IF(timer_.create,
		(&queue_, &callback_timer_, 0.1));

	//	Dispatch RV events...
	TibrvStatus rv_status;

	do {
		rv_status = queue_group_.timedDispatch(0.1);
		if (MLB::Utility::CriticalEventTest()) {
			LogInfo << "RvdMonDLossitor is performing an asynchronous exit "
				"due to receipt of a signal." << std::endl;
			break;
		}
	} while ((rv_status == TIBRV_OK) || (rv_status == TIBRV_TIMEOUT));

	if ((rv_status != TIBRV_OK) && (rv_status != TIBRV_TIMEOUT))
		throw RvExceptionStatus(rv_status,
			"Error occurred while dispatching from a Rendezvous queue.");
}
//	////////////////////////////////////////////////////////////////////////////

//	////////////////////////////////////////////////////////////////////////////
void RvdMonDLoss::EmitStatus() const
{
	unsigned int                 total_count = 0;
	RvdMonDLossServiceSetIterC iter_b(service_set_.begin());
	RvdMonDLossServiceSetIterC iter_e(service_set_.end());

	for ( ; iter_b != iter_e ; ++iter_b)
		total_count += static_cast<unsigned int>(iter_b->host_set_.size());

	std::ostringstream out_string;

	out_string <<
		MLB::Utility::TimeVal::Now().ToString().substr(0, 19) <<
		std::setw(10)  << static_cast<unsigned int>(service_set_.size()) << " " <<
		std::setw(10)  << total_count << " " <<
		std::setw(10)  << bad_count_ << " " <<
		std::setw(22) << heartbeat_count_;

	if (log_flag_)
		MyLogManager.EmitLiteral(out_string.str());
	else
		std::cout << out_string.str() << std::endl;
}
//	////////////////////////////////////////////////////////////////////////////

//	////////////////////////////////////////////////////////////////////////////
void RvdMonDLoss::ProcessEventOnMsg(TibrvMsgCallback *,
	TibrvListener *listener_ptr, TibrvMsg &msg_recv)
{
	try {
		RvdMonDLossService *service_ptr =
			static_cast<RvdMonDLossService *>(listener_ptr->getClosure());
		service_ptr->ApplyMessage(my_name_, queue_group_, valid_versions_set_,
			longest_snd_spec_, msg_recv, bad_count_);
		++heartbeat_count_;
	}
	catch (const std::exception &except) {
		LogError << "Error processing message: " << except.what() << std::endl;
	}
}
//	////////////////////////////////////////////////////////////////////////////

//	////////////////////////////////////////////////////////////////////////////
void RvdMonDLoss::ProcessEventOnTimer(TibrvTimerCallback *, TibrvTimer *)
{
	if (timer_count_ == -1) {
		EmitStatus();
		timer_count_ = 0;
	}
	else {
		++timer_count_;
		if (timer_count_ && (!(timer_count_ % 100))) {
			EmitStatus();
			timer_count_ = 0;
		}
	}
}
//	////////////////////////////////////////////////////////////////////////////

//	////////////////////////////////////////////////////////////////////////////
void RvdMonDLoss::ReportException(const std::exception *except_ptr)
{
	LogWarning << "Exception encountered in Tib/Rendezvous callback: " <<
		((except_ptr != NULL) ? except_ptr->what() : "*UNSPECIFIED*") <<
		std::endl;
}
//	////////////////////////////////////////////////////////////////////////////

} // namespace RvInfo

} // namespace RvUtilX

} // namespace MLB

//#include <SockLibX/ParseCmdLineArg.hpp>

//using namespace MLB::RvUtilX::RvInfo;

//	////////////////////////////////////////////////////////////////////////////
int main(int argc, char **argv)
{
	int          return_code = EXIT_SUCCESS;
	std::string  my_name     = MLB::Utility::GetFileNamePortion(argv[0]);

	// //////////////////////////////////////////////////////////////////////
	// //////////////////////////////////////////////////////////////////////
	//	Help may have been requested on the command line...
	// //////////////////////////////////////////////////////////////////////
	if (MLB::RvUtilX::RvParseCmdLineArg::HasCmdLineHelp(argc, argv, 1)) {
		std::cout << "USAGE: " << std::endl <<
			"   " << argv[0] << " " <<
			"[ -service_net <RV-service>[:<RV-network>] ... ] " <<
			"[ -daemon <RV-daemon> ] " <<
			"[ -valid_versions <rvd-version>[,<rvd-version>[,...]] ] " <<
			"[ -logging <boolean> ( = FALSE ) ] " <<
			"[ -logging_directory <directory-path-for-log-files> ( = ./ ) ]\n\n" <<
"\
   -help\n\
      Produces this output.\n\n\
   -service_net <RV-service>[:<RV-network>]\n\
      Specifies a Tib/Rendezvous service:network communications for\n\
      analysis by this program.\n\n\
      This parameter may be specified multiple times.\n\n\
   -daemon <RV-daemon>\n\
      The Tib/Rendezvous daemon to which the connection is to be made.\n\n\
   -valid_versions <rvd-version>[,<rvd-version>[,...]]\n\
      Specifies one or more versions considered to be valid by this program.\n\
      Multiple rvd version numbers may be specified as a single parameter by\n\
      separating them with comma (','). In addition, this parameter may be\n\
      specified multiple times to produce an aggregated list of versions.\n\n\
   -logging <boolean>\n\
      Specifies whether logging is to be performed.\n\n\
   -logging_directory <directory-in-which-to-log>\n\
      Specifies the directory in which to log." <<
			std::endl << std::endl;
		exit(EXIT_SUCCESS);
	}
	// //////////////////////////////////////////////////////////////////////

	try {
		MLB::Utility::CriticalEventContext  critical_event_context;
		MLB::SockLibX::SockLibXContext      socket_lib;
		MLB::RvUtilX::RvInfo::RvdMonDLoss rvd_inspector;
		rvd_inspector.ParseCmdLine(argc, argv);
		rvd_inspector.Start();
	}
	catch (const std::exception &except) {
		std::cerr << std::endl << my_name << ": fatal error encountered: " <<
			except.what() << std::endl;
		return_code = EXIT_FAILURE;
	}

	return(return_code);
}
//	////////////////////////////////////////////////////////////////////////////

